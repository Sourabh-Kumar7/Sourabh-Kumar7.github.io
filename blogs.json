{"status":"ok","feed":{"url":"https://medium.com/feed/@@sourabhkr","title":"Stories by Sourabh Kumar on Medium","link":"https://medium.com/@sourabhkr?source=rss-4cc8effadc6e------2","author":"","description":"Stories by Sourabh Kumar on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*5zq9xLJmjpcBS2AVn68iJQ.png"},"items":[{"title":"Day-21: State Pattern","pubDate":"2024-08-07 02:42:59","link":"https://sourabhkr.medium.com/day-21-state-pattern-bb321d74d0e5?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/bb321d74d0e5","author":"Sourabh Kumar","thumbnail":"","description":"\n<h3>Introduction</h3>\n<p>Hello design pattern enthusiasts! Welcome to Day-21 of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a><strong>. </strong>Today we\u2019ll learn about <strong>State Pattern</strong>. <em>It a behavioral design pattern that lets an object alter its behavior when its internal state\u00a0changes.</em></p>\n<h3>Problem</h3>\n<p>Let\u2019s suppose we\u2019re building a basic text editor. This editor can be in three\u00a0states:</p>\n<ul>\n<li>\n<strong>Normal:</strong> Regular text\u00a0editing.</li>\n<li>\n<strong>Bold:</strong> Text formatting in\u00a0bold.</li>\n<li>\n<strong>Italic:</strong> Text formatting in\u00a0italics.</li>\n</ul>\n<p>The editor should be able to switch between these states and apply the corresponding formatting to the\u00a0text.</p>\n<h4><strong>The naive approach:</strong></h4>\n<p>We might start with a simple TextEditor class:</p>\n<pre>class TextEditor {<br>    private String text;<br>    private String format = \"normal\";<br><br>    public void append(String text) {<br>        if (format.equals(\"bold\")) {<br>            this.text += \"&lt;b&gt;\" + text + \"&lt;/b&gt;\";<br>        } else if (format.equals(\"italic\")) {<br>            this.text += \"&lt;i&gt;\" + text + \"&lt;/i&gt;\";<br>        } else {<br>            this.text += text;<br>        }<br>    }<br><br>    // ... other methods ...<br>}</pre>\n<p>As you can see, the append method is already cluttered with conditional logic. Imagine adding more formatting options like underline, strikethrough, etc. The append method would become increasingly complex and difficult to maintain.</p>\n<h3>Solution</h3>\n<p>To address this, we can apply the State pattern. Here\u2019s\u00a0how:</p>\n<ul><li>Create an interface for\u00a0states:</li></ul>\n<pre>interface TextFormatState {<br>    void append(TextEditor editor, String text);<br>}</pre>\n<ul><li>Create concrete state\u00a0classes:</li></ul>\n<pre>class NormalState implements TextFormatState {<br>    @Override<br>    public void append(TextEditor editor, String text) {<br>        editor.text += text;<br>    }<br>}<br><br>class BoldState implements TextFormatState {<br>    @Override<br>    public void append(TextEditor editor, String text) {<br>        editor.text += \"&lt;b&gt;\" + text + \"&lt;/b&gt;\";<br>    }<br>}<br><br>// ... ItalicState ...</pre>\n<ul><li>Modify the TextEditor class:</li></ul>\n<pre>class TextEditor {<br>    private String text;<br>    private TextFormatState state;<br><br>    public TextEditor() {<br>        state = new NormalState();<br>    }<br><br>    public void append(String text) {<br>        state.append(this, text);<br>    }<br><br>    public void setBold() {<br>        state = new BoldState();<br>    }<br><br>    // ... other methods ...<br>}</pre>\n<p>Now, the append method is clean and concise. The formatting logic is encapsulated within the state classes. Adding new formatting options simply requires creating a new state\u00a0class.</p>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Context</strong></li>\n<li><strong>State</strong></li>\n<li><strong>Concrete State Subclasses</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sPS7mQmWImYvlpHo6-nPeg.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h4><strong>Benefits of the State\u00a0Pattern:</strong></h4>\n<ul>\n<li>\n<strong>Improved Maintainability:</strong> Behavior logic is isolated within State objects, making code easier to understand and\u00a0modify.</li>\n<li>\n<strong>Flexibility:</strong> New states can be added by creating new Concrete State classes without modifying existing\u00a0code.</li>\n<li>\n<strong>Encapsulation:</strong> The Context object doesn\u2019t need to be aware of the specific logic within each State\u00a0object.</li>\n</ul>\n<h4><strong>Real-World Examples:</strong></h4>\n<ul>\n<li>\n<strong>Traffic Light Controller:</strong> A traffic light can be in a red, yellow, or green state. The State pattern allows each state to define the light sequence and transition logic.</li>\n<li>\n<strong>Vending Machine:</strong> A vending machine can be in idle, coin-inserted, product-selected, and dispensing states. Each state handles user interactions and transitions to other\u00a0states.</li>\n<li>\n<strong>Game Character:</strong> A game character can be in running, jumping, attacking, or idle states. Each state defines the character\u2019s movement and animations.</li>\n</ul>\n<h3><strong>Conclusion:</strong></h3>\n<p>The State pattern offers a structured approach to managing object behavior based on state. By separating behavior into distinct State objects, you improve code readability, maintainability, and flexibility.</p>\n<p>Have you used the State pattern in your projects? Share your experiences and any challenges you faced in the comments below! We\u2019ll continue our design pattern journey tomorrow, so stay\u00a0tuned!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bb321d74d0e5\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Introduction</h3>\n<p>Hello design pattern enthusiasts! Welcome to Day-21 of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a><strong>. </strong>Today we\u2019ll learn about <strong>State Pattern</strong>. <em>It a behavioral design pattern that lets an object alter its behavior when its internal state\u00a0changes.</em></p>\n<h3>Problem</h3>\n<p>Let\u2019s suppose we\u2019re building a basic text editor. This editor can be in three\u00a0states:</p>\n<ul>\n<li>\n<strong>Normal:</strong> Regular text\u00a0editing.</li>\n<li>\n<strong>Bold:</strong> Text formatting in\u00a0bold.</li>\n<li>\n<strong>Italic:</strong> Text formatting in\u00a0italics.</li>\n</ul>\n<p>The editor should be able to switch between these states and apply the corresponding formatting to the\u00a0text.</p>\n<h4><strong>The naive approach:</strong></h4>\n<p>We might start with a simple TextEditor class:</p>\n<pre>class TextEditor {<br>    private String text;<br>    private String format = \"normal\";<br><br>    public void append(String text) {<br>        if (format.equals(\"bold\")) {<br>            this.text += \"&lt;b&gt;\" + text + \"&lt;/b&gt;\";<br>        } else if (format.equals(\"italic\")) {<br>            this.text += \"&lt;i&gt;\" + text + \"&lt;/i&gt;\";<br>        } else {<br>            this.text += text;<br>        }<br>    }<br><br>    // ... other methods ...<br>}</pre>\n<p>As you can see, the append method is already cluttered with conditional logic. Imagine adding more formatting options like underline, strikethrough, etc. The append method would become increasingly complex and difficult to maintain.</p>\n<h3>Solution</h3>\n<p>To address this, we can apply the State pattern. Here\u2019s\u00a0how:</p>\n<ul><li>Create an interface for\u00a0states:</li></ul>\n<pre>interface TextFormatState {<br>    void append(TextEditor editor, String text);<br>}</pre>\n<ul><li>Create concrete state\u00a0classes:</li></ul>\n<pre>class NormalState implements TextFormatState {<br>    @Override<br>    public void append(TextEditor editor, String text) {<br>        editor.text += text;<br>    }<br>}<br><br>class BoldState implements TextFormatState {<br>    @Override<br>    public void append(TextEditor editor, String text) {<br>        editor.text += \"&lt;b&gt;\" + text + \"&lt;/b&gt;\";<br>    }<br>}<br><br>// ... ItalicState ...</pre>\n<ul><li>Modify the TextEditor class:</li></ul>\n<pre>class TextEditor {<br>    private String text;<br>    private TextFormatState state;<br><br>    public TextEditor() {<br>        state = new NormalState();<br>    }<br><br>    public void append(String text) {<br>        state.append(this, text);<br>    }<br><br>    public void setBold() {<br>        state = new BoldState();<br>    }<br><br>    // ... other methods ...<br>}</pre>\n<p>Now, the append method is clean and concise. The formatting logic is encapsulated within the state classes. Adding new formatting options simply requires creating a new state\u00a0class.</p>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Context</strong></li>\n<li><strong>State</strong></li>\n<li><strong>Concrete State Subclasses</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sPS7mQmWImYvlpHo6-nPeg.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h4><strong>Benefits of the State\u00a0Pattern:</strong></h4>\n<ul>\n<li>\n<strong>Improved Maintainability:</strong> Behavior logic is isolated within State objects, making code easier to understand and\u00a0modify.</li>\n<li>\n<strong>Flexibility:</strong> New states can be added by creating new Concrete State classes without modifying existing\u00a0code.</li>\n<li>\n<strong>Encapsulation:</strong> The Context object doesn\u2019t need to be aware of the specific logic within each State\u00a0object.</li>\n</ul>\n<h4><strong>Real-World Examples:</strong></h4>\n<ul>\n<li>\n<strong>Traffic Light Controller:</strong> A traffic light can be in a red, yellow, or green state. The State pattern allows each state to define the light sequence and transition logic.</li>\n<li>\n<strong>Vending Machine:</strong> A vending machine can be in idle, coin-inserted, product-selected, and dispensing states. Each state handles user interactions and transitions to other\u00a0states.</li>\n<li>\n<strong>Game Character:</strong> A game character can be in running, jumping, attacking, or idle states. Each state defines the character\u2019s movement and animations.</li>\n</ul>\n<h3><strong>Conclusion:</strong></h3>\n<p>The State pattern offers a structured approach to managing object behavior based on state. By separating behavior into distinct State objects, you improve code readability, maintainability, and flexibility.</p>\n<p>Have you used the State pattern in your projects? Share your experiences and any challenges you faced in the comments below! We\u2019ll continue our design pattern journey tomorrow, so stay\u00a0tuned!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bb321d74d0e5\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["software-development","state-pattern","design-patterns","system-design-interview","software-engineering"]},{"title":"Day 20: Memento Pattern\u200a\u2014\u200aCapturing Object States","pubDate":"2024-08-06 00:30:58","link":"https://sourabhkr.medium.com/day-20-memento-pattern-capturing-object-states-44bb89e4e7f3?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/44bb89e4e7f3","author":"Sourabh Kumar","thumbnail":"","description":"\n<h3>Day 20: Memento Pattern\u200a\u2014\u200aCapturing Object\u00a0States</h3>\n<h3>Introduction</h3>\n<p>Yesterday, we explored the Observer pattern. Today, let\u2019s dive into a pattern that\u2019s crucial for preserving object states: the Memento\u00a0pattern.</p>\n<p>I\u2019ve often found myself in situations where I needed to undo an action in an application. Whether it\u2019s a simple text editor or a complex image manipulation tool, the ability to revert changes is a fundamental user expectation. Initially, I thought this would be straightforward. I\u2019d simply create a copy of the object\u2019s state before performing an action, and then restore it when needed. But as I dug deeper, I realized the complexities involved.</p>\n<h3>The Challenges</h3>\n<p>Copying an object\u2019s state isn\u2019t as simple as it seems. Objects often have intricate internal structures and private fields. Directly accessing and copying these fields would violate encapsulation and make the code brittle. Moreover, even if I managed to create a copy, storing numerous copies would be inefficient and potentially lead to performance issues.</p>\n<h3>The Memento\u00a0Solution</h3>\n<p>The Memento pattern elegantly addresses these challenges. It introduces the concept of a Memento object, which encapsulates the internal state of another object, called the Originator. The key point is that only the Originator can access the Memento's details. Other objects, often referred to as Caretakers, can store and retrieve mementos without knowing their exact contents.</p>\n<p><strong>How it\u00a0works:</strong></p>\n<ol>\n<li>\n<strong>Create a Memento:</strong> When the Originator is about to perform an operation, it creates a Memento capturing its current\u00a0state.</li>\n<li>\n<strong>Store the Memento:</strong> The Caretaker (often a history object) stores the Memento for later\u00a0use.</li>\n<li>\n<strong>Restore State:</strong> When the Originator needs to undo an operation, it retrieves a Memento from the Caretaker and restores its state based on the information within.</li>\n</ol>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Memento</strong></li>\n<li><strong>Originator</strong></li>\n<li><strong>Caretaeker</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4T8C7Fwpk_c6TdO2r6GcBw.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h3>Implementing Memento</h3>\n<p>Let\u2019s consider a simple text editor\u00a0example.</p>\n<pre>class TextEditor {<br>    private String content;<br><br>    public Memento createMemento() {<br>        return new Memento(content);<br>    }<br><br>    public void restore(Memento memento) {<br>        content = memento.getState();<br>    }<br><br>    // ... other methods ...<br>}<br><br>class Memento {<br>    private String state;<br><br>    public Memento(String state) {<br>        this.state = state;<br>    }<br><br>    public String getState() {<br>        return state;<br>    }<br>}<br><br>class History {<br>    private List&lt;Memento&gt; mementos = new ArrayList&lt;&gt;();<br><br>    public void push(Memento memento) {<br>        mementos.add(memento);<br>    }<br><br>    public Memento pop() {<br>        return mementos.remove(mementos.size() - 1);<br>    }<br>}</pre>\n<p>In this example, the TextEditor creates a Memento containing its current content. The History object stores these mementos. When the user wants to undo, the History pops a Memento and the TextEditor restores its\u00a0state.</p>\n<h3>Key Benefits</h3>\n<ul>\n<li>\n<strong>Encapsulation:</strong> The Memento protects the Originator's internal\u00a0state.</li>\n<li>\n<strong>Flexibility:</strong> The Caretaker can manage mementos without knowing their\u00a0details.</li>\n<li>\n<strong>Undo/Redo Functionality:</strong> Easily implemented by storing and retrieving mementos.</li>\n</ul>\n<h3>Real-World Applications</h3>\n<p>The Memento pattern is widely used\u00a0in:</p>\n<ul>\n<li>Text editors and word processors</li>\n<li>Game development for saving and loading game\u00a0states</li>\n<li>Version control\u00a0systems</li>\n</ul>\n<h3>Other Examples</h3>\n<ul>\n<li>java.io.Serializable all implementations of this interface would be examples of the memento\u00a0pattern.</li>\n<li>javax.faces.component.StateHolder this interface is implemented by classes that need to save their state between requests.</li>\n</ul>\n<p>By understanding and applying the Memento pattern, you can create robust applications that allow users to undo and redo actions effectively.</p>\n<p><strong>Tomorrow, we\u2019ll delve into the State pattern, another pattern related to object\u00a0states.</strong></p>\n<p><em>What are your thoughts on the Memento pattern? Have you encountered similar challenges in your projects?</em></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=44bb89e4e7f3\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Day 20: Memento Pattern\u200a\u2014\u200aCapturing Object\u00a0States</h3>\n<h3>Introduction</h3>\n<p>Yesterday, we explored the Observer pattern. Today, let\u2019s dive into a pattern that\u2019s crucial for preserving object states: the Memento\u00a0pattern.</p>\n<p>I\u2019ve often found myself in situations where I needed to undo an action in an application. Whether it\u2019s a simple text editor or a complex image manipulation tool, the ability to revert changes is a fundamental user expectation. Initially, I thought this would be straightforward. I\u2019d simply create a copy of the object\u2019s state before performing an action, and then restore it when needed. But as I dug deeper, I realized the complexities involved.</p>\n<h3>The Challenges</h3>\n<p>Copying an object\u2019s state isn\u2019t as simple as it seems. Objects often have intricate internal structures and private fields. Directly accessing and copying these fields would violate encapsulation and make the code brittle. Moreover, even if I managed to create a copy, storing numerous copies would be inefficient and potentially lead to performance issues.</p>\n<h3>The Memento\u00a0Solution</h3>\n<p>The Memento pattern elegantly addresses these challenges. It introduces the concept of a Memento object, which encapsulates the internal state of another object, called the Originator. The key point is that only the Originator can access the Memento's details. Other objects, often referred to as Caretakers, can store and retrieve mementos without knowing their exact contents.</p>\n<p><strong>How it\u00a0works:</strong></p>\n<ol>\n<li>\n<strong>Create a Memento:</strong> When the Originator is about to perform an operation, it creates a Memento capturing its current\u00a0state.</li>\n<li>\n<strong>Store the Memento:</strong> The Caretaker (often a history object) stores the Memento for later\u00a0use.</li>\n<li>\n<strong>Restore State:</strong> When the Originator needs to undo an operation, it retrieves a Memento from the Caretaker and restores its state based on the information within.</li>\n</ol>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Memento</strong></li>\n<li><strong>Originator</strong></li>\n<li><strong>Caretaeker</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4T8C7Fwpk_c6TdO2r6GcBw.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h3>Implementing Memento</h3>\n<p>Let\u2019s consider a simple text editor\u00a0example.</p>\n<pre>class TextEditor {<br>    private String content;<br><br>    public Memento createMemento() {<br>        return new Memento(content);<br>    }<br><br>    public void restore(Memento memento) {<br>        content = memento.getState();<br>    }<br><br>    // ... other methods ...<br>}<br><br>class Memento {<br>    private String state;<br><br>    public Memento(String state) {<br>        this.state = state;<br>    }<br><br>    public String getState() {<br>        return state;<br>    }<br>}<br><br>class History {<br>    private List&lt;Memento&gt; mementos = new ArrayList&lt;&gt;();<br><br>    public void push(Memento memento) {<br>        mementos.add(memento);<br>    }<br><br>    public Memento pop() {<br>        return mementos.remove(mementos.size() - 1);<br>    }<br>}</pre>\n<p>In this example, the TextEditor creates a Memento containing its current content. The History object stores these mementos. When the user wants to undo, the History pops a Memento and the TextEditor restores its\u00a0state.</p>\n<h3>Key Benefits</h3>\n<ul>\n<li>\n<strong>Encapsulation:</strong> The Memento protects the Originator's internal\u00a0state.</li>\n<li>\n<strong>Flexibility:</strong> The Caretaker can manage mementos without knowing their\u00a0details.</li>\n<li>\n<strong>Undo/Redo Functionality:</strong> Easily implemented by storing and retrieving mementos.</li>\n</ul>\n<h3>Real-World Applications</h3>\n<p>The Memento pattern is widely used\u00a0in:</p>\n<ul>\n<li>Text editors and word processors</li>\n<li>Game development for saving and loading game\u00a0states</li>\n<li>Version control\u00a0systems</li>\n</ul>\n<h3>Other Examples</h3>\n<ul>\n<li>java.io.Serializable all implementations of this interface would be examples of the memento\u00a0pattern.</li>\n<li>javax.faces.component.StateHolder this interface is implemented by classes that need to save their state between requests.</li>\n</ul>\n<p>By understanding and applying the Memento pattern, you can create robust applications that allow users to undo and redo actions effectively.</p>\n<p><strong>Tomorrow, we\u2019ll delve into the State pattern, another pattern related to object\u00a0states.</strong></p>\n<p><em>What are your thoughts on the Memento pattern? Have you encountered similar challenges in your projects?</em></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=44bb89e4e7f3\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["software-development","design-patterns","system-design-interview","memento-pattern","software-engineering"]},{"title":"Day 19: Mediator Pattern","pubDate":"2024-08-05 00:51:09","link":"https://sourabhkr.medium.com/day-19-mediator-pattern-c3af28e584be?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/c3af28e584be","author":"Sourabh Kumar","thumbnail":"","description":"\n<p>Hey design pattern enthusiasts!</p>\n<p>Continuing our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-day design pattern challenge</strong></a>, today we\u2019ll explore the <strong>Mediator Pattern</strong>. This pattern tackles the problem of complex communication networks between objects in your\u00a0code.</p>\n<h3><strong>Introduction</strong></h3>\n<p>Imagine you\u2019re building a chat application. Users can send messages to each other, and the application needs to manage the flow of messages and update the UI accordingly. A naive approach might involve direct communication between the user interface (UI) components and the chat service. However, this can lead to tightly coupled code and difficulty in managing interactions as the application grows.</p>\n<h3><strong>Problem</strong></h3>\n<p>Direct communication between objects can create a web of dependencies, making the code difficult to understand, maintain, and test. As the number of objects increases, the complexity of managing these interactions explodes.</p>\n<h3><strong>Solution</strong></h3>\n<p>The Mediator Pattern introduces a central mediator object that acts as an intermediary between other objects in the system. Objects communicate their needs through the mediator, which then facilitates the interaction and updates other objects as necessary.</p>\n<h4><strong>Benefits:</strong></h4>\n<ul>\n<li>\n<strong>Reduced Coupling:</strong> Objects no longer need to be aware of each other\u2019s implementation details. They simply interact with the mediator.</li>\n<li>\n<strong>Improved Maintainability:</strong> Changes to communication logic are centralized in the mediator, making the code easier to understand and\u00a0modify.</li>\n<li>\n<strong>Testability:</strong> By isolating communication within the mediator, testing becomes more manageable.</li>\n</ul>\n<h4>Class Diagram</h4>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Mediator</strong></li>\n<li><strong>Concrete Mediator</strong></li>\n<li><strong>Colleague Classes</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fcH2yrYkvyZTs5PC3pApVA.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h3><strong>Example</strong></h3>\n<p>Here\u2019s a simplified example of the Mediator Pattern in a chat application:</p>\n<pre>public interface ChatMediator {<br>  void sendMessage(User user, String message);<br>  void userJoined(User user);<br>  void userLeft(User user);<br>}<br><br>public class ChatRoom implements ChatMediator {<br>  private List&lt;User&gt; users;<br><br>  public ChatRoom() {<br>    this.users = new ArrayList&lt;&gt;();<br>  }<br><br>  @Override<br>  public void sendMessage(User user, String message) {<br>    for (User recipient : users) {<br>      if (recipient != user) {<br>        recipient.receiveMessage(user.getName() + \": \" + message);<br>      }<br>    }<br>  }<br><br>  @Override<br>  public void userJoined(User user) {<br>    this.users.add(user);<br>    user.setMediator(this);<br>    broadcast(user.getName() + \" joined the chat\");<br>  }<br><br>  @Override<br>  public void userLeft(User user) {<br>    this.users.remove(user);<br>    broadcast(user.getName() + \" left the chat\");<br>  }<br><br>  private void broadcast(String message) {<br>    for (User user : users) {<br>      user.receiveMessage(message);<br>    }<br>  }<br>}<br><br>public class User {<br>  private ChatMediator mediator;<br>  private String name;<br><br>  public User(String name) {<br>    this.name = name;<br>  }<br><br>  public void setMediator(ChatMediator mediator) {<br>    this.mediator = mediator;<br>  }<br><br>  public void sendMessage(String message) {<br>    mediator.sendMessage(this, message);<br>  }<br><br>  public void receiveMessage(String message) {<br>    System.out.println(message);<br>  }<br>}</pre>\n<p>In this example, the ChatRoom acts as the mediator. Users communicate by sending messages to the mediator, which then broadcasts the message to other users. This approach isolates communication logic and reduces coupling between\u00a0objects.</p>\n<h4><strong>Real-World Applications</strong></h4>\n<ul>\n<li>User interfaces with multiple interacting components like buttons, menus, and text\u00a0boxes.</li>\n<li>Graphical editors where shapes and tools need to interact.</li>\n<li>Event systems where various objects subscribe to and publish\u00a0events.</li>\n</ul>\n<h4><strong>When to Use the Mediator\u00a0Pattern</strong></h4>\n<ul>\n<li>When complex communication exists between a large number of\u00a0objects.</li>\n<li>When you want to centralize and decouple communication logic.</li>\n<li>When testability of object interactions is a\u00a0concern.</li>\n</ul>\n<h4><strong>Additional Considerations</strong></h4>\n<ul>\n<li>The mediator can become a central point of complexity if not designed carefully.</li>\n<li>Overuse of the mediator pattern can lead to an unnecessary layer of abstraction.</li>\n</ul>\n<h3><strong>Conclusion</strong></h3>\n<p>The Mediator Pattern provides a structured approach to managing communication between objects, promoting loose coupling, maintainability, and testability in your codebase. By mastering this pattern, you can design more manageable and scalable object interactions.</p>\n<p><strong>Join me tomorrow for Day 20, where we\u2019ll explore the Memento Pattern\u200a\u2014\u200aa powerful mechanism for notifying objects about\u00a0changes!</strong></p>\n<p>Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0!</p>\n<h3><strong>References</strong></h3>\n<ul>\n<li>Head First Design Patterns\u00a0(Book)</li>\n<li><a href=\"https://refactoring.guru/design-patterns/mediator\">Refactoring Guru (n.d.). Mediator\u00a0Pattern.</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c3af28e584be\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Hey design pattern enthusiasts!</p>\n<p>Continuing our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-day design pattern challenge</strong></a>, today we\u2019ll explore the <strong>Mediator Pattern</strong>. This pattern tackles the problem of complex communication networks between objects in your\u00a0code.</p>\n<h3><strong>Introduction</strong></h3>\n<p>Imagine you\u2019re building a chat application. Users can send messages to each other, and the application needs to manage the flow of messages and update the UI accordingly. A naive approach might involve direct communication between the user interface (UI) components and the chat service. However, this can lead to tightly coupled code and difficulty in managing interactions as the application grows.</p>\n<h3><strong>Problem</strong></h3>\n<p>Direct communication between objects can create a web of dependencies, making the code difficult to understand, maintain, and test. As the number of objects increases, the complexity of managing these interactions explodes.</p>\n<h3><strong>Solution</strong></h3>\n<p>The Mediator Pattern introduces a central mediator object that acts as an intermediary between other objects in the system. Objects communicate their needs through the mediator, which then facilitates the interaction and updates other objects as necessary.</p>\n<h4><strong>Benefits:</strong></h4>\n<ul>\n<li>\n<strong>Reduced Coupling:</strong> Objects no longer need to be aware of each other\u2019s implementation details. They simply interact with the mediator.</li>\n<li>\n<strong>Improved Maintainability:</strong> Changes to communication logic are centralized in the mediator, making the code easier to understand and\u00a0modify.</li>\n<li>\n<strong>Testability:</strong> By isolating communication within the mediator, testing becomes more manageable.</li>\n</ul>\n<h4>Class Diagram</h4>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Mediator</strong></li>\n<li><strong>Concrete Mediator</strong></li>\n<li><strong>Colleague Classes</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fcH2yrYkvyZTs5PC3pApVA.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h3><strong>Example</strong></h3>\n<p>Here\u2019s a simplified example of the Mediator Pattern in a chat application:</p>\n<pre>public interface ChatMediator {<br>  void sendMessage(User user, String message);<br>  void userJoined(User user);<br>  void userLeft(User user);<br>}<br><br>public class ChatRoom implements ChatMediator {<br>  private List&lt;User&gt; users;<br><br>  public ChatRoom() {<br>    this.users = new ArrayList&lt;&gt;();<br>  }<br><br>  @Override<br>  public void sendMessage(User user, String message) {<br>    for (User recipient : users) {<br>      if (recipient != user) {<br>        recipient.receiveMessage(user.getName() + \": \" + message);<br>      }<br>    }<br>  }<br><br>  @Override<br>  public void userJoined(User user) {<br>    this.users.add(user);<br>    user.setMediator(this);<br>    broadcast(user.getName() + \" joined the chat\");<br>  }<br><br>  @Override<br>  public void userLeft(User user) {<br>    this.users.remove(user);<br>    broadcast(user.getName() + \" left the chat\");<br>  }<br><br>  private void broadcast(String message) {<br>    for (User user : users) {<br>      user.receiveMessage(message);<br>    }<br>  }<br>}<br><br>public class User {<br>  private ChatMediator mediator;<br>  private String name;<br><br>  public User(String name) {<br>    this.name = name;<br>  }<br><br>  public void setMediator(ChatMediator mediator) {<br>    this.mediator = mediator;<br>  }<br><br>  public void sendMessage(String message) {<br>    mediator.sendMessage(this, message);<br>  }<br><br>  public void receiveMessage(String message) {<br>    System.out.println(message);<br>  }<br>}</pre>\n<p>In this example, the ChatRoom acts as the mediator. Users communicate by sending messages to the mediator, which then broadcasts the message to other users. This approach isolates communication logic and reduces coupling between\u00a0objects.</p>\n<h4><strong>Real-World Applications</strong></h4>\n<ul>\n<li>User interfaces with multiple interacting components like buttons, menus, and text\u00a0boxes.</li>\n<li>Graphical editors where shapes and tools need to interact.</li>\n<li>Event systems where various objects subscribe to and publish\u00a0events.</li>\n</ul>\n<h4><strong>When to Use the Mediator\u00a0Pattern</strong></h4>\n<ul>\n<li>When complex communication exists between a large number of\u00a0objects.</li>\n<li>When you want to centralize and decouple communication logic.</li>\n<li>When testability of object interactions is a\u00a0concern.</li>\n</ul>\n<h4><strong>Additional Considerations</strong></h4>\n<ul>\n<li>The mediator can become a central point of complexity if not designed carefully.</li>\n<li>Overuse of the mediator pattern can lead to an unnecessary layer of abstraction.</li>\n</ul>\n<h3><strong>Conclusion</strong></h3>\n<p>The Mediator Pattern provides a structured approach to managing communication between objects, promoting loose coupling, maintainability, and testability in your codebase. By mastering this pattern, you can design more manageable and scalable object interactions.</p>\n<p><strong>Join me tomorrow for Day 20, where we\u2019ll explore the Memento Pattern\u200a\u2014\u200aa powerful mechanism for notifying objects about\u00a0changes!</strong></p>\n<p>Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0!</p>\n<h3><strong>References</strong></h3>\n<ul>\n<li>Head First Design Patterns\u00a0(Book)</li>\n<li><a href=\"https://refactoring.guru/design-patterns/mediator\">Refactoring Guru (n.d.). Mediator\u00a0Pattern.</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c3af28e584be\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["design-patterns","system-design-interview","mediator-pattern","software-engineering","software-development"]},{"title":"Day 18: Iterator Pattern\u200a\u2014\u200aAccessing Elements Without Exposing the Underlying Structure","pubDate":"2024-08-03 17:45:39","link":"https://sourabhkr.medium.com/day-18-iterator-pattern-accessing-elements-without-exposing-the-underlying-structure-24617aaff868?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/24617aaff868","author":"Sourabh Kumar","thumbnail":"","description":"\n<h3>Day 18: Iterator Pattern\u200a\u2014\u200aAccessing Elements Without Exposing the Underlying Structure</h3>\n<h3>Introduction</h3>\n<p>Welcome back, design pattern enthusiasts! Yesterday, we delved into the Command Pattern, a powerful tool for encapsulating requests and decoupling them from execution. Today, on <strong>Day 18</strong> of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>, we\u2019ll explore the <strong>Iterator Pattern</strong>. <em>This pattern provides a way to access the elements of an object collection without exposing its underlying internal structure.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/420/1*poltliMcDDCW029Eun3Nhg.png\"><figcaption>From refactoring.guru</figcaption></figure><h3>Problem</h3>\n<p>Imagine you\u2019re building an e-commerce website. Your website needs to display a list of products to users. This list could be implemented using an array, a linked list, or even a custom data structure. However, the specific implementation details shouldn\u2019t matter to the code that displays the products.</p>\n<p>Here\u2019s a simplified example of a product list implemented as an\u00a0array:</p>\n<pre>public class ProductList {<br>  private Product[] products;<br><br>  public ProductList(Product[] products) {<br>    this.products = products;<br>  }<br><br>  public void displayProducts() {<br>    for (Product product : products) {<br>      System.out.println(product.getName());<br>    }<br>  }<br>}</pre>\n<p>While this code works, it tightly couples the ProductList class with the for-each loop syntax. If we decide to change the underlying implementation to a linked list or a custom data structure, we'd need to modify the displayProducts method as well. This can be inconvenient and error-prone.</p>\n<h3>Solution</h3>\n<p>The Iterator Pattern introduces an Iterator interface that specifies a contract for iterating over the elements of a collection. This interface typically has a hasNext() method to check if there are more elements in the collection and a next() method to retrieve the next\u00a0element.</p>\n<p>Here\u2019s how the ProductList class can be refactored using the Iterator\u00a0Pattern:</p>\n<pre>public class ProductList {<br>  private List&lt;Product&gt; products;<br><br>  public ProductList(List&lt;Product&gt; products) {<br>    this.products = products;<br>  }<br><br>  public Iterator&lt;Product&gt; getIterator() {<br>    return new ProductListIterator(this.products);<br>  }<br>}<br><br>public interface Iterator&lt;T&gt; {<br>  boolean hasNext();<br><br>  T next();<br>}<br><br>public class ProductListIterator implements Iterator&lt;Product&gt; {<br>  private List&lt;Product&gt; products;<br>  private int currentPosition;<br><br>  public ProductListIterator(List&lt;Product&gt; products) {<br>    this.products = products;<br>    this.currentPosition = 0;<br>  }<br><br>  @Override<br>  public boolean hasNext() {<br>    return currentPosition &lt; products.size();<br>  }<br><br>  @Override<br>  public Product next() {<br>    if (hasNext()) {<br>      return products.get(currentPosition++);<br>    } else {<br>      throw new NoSuchElementException();<br>    }<br>  }<br>}</pre>\n<p>Now, the ProductList class provides a getIterator method that returns an Iterator object. The displayProducts method can be rewritten to use this iterator:</p>\n<pre>public void displayProducts() {<br>  Iterator&lt;Product&gt; iterator = getIterator();<br>  while (iterator.hasNext()) {<br>    Product product = iterator.next();<br>    System.out.println(product.getName());<br>  }<br>}</pre>\n<h4>This approach offers several advantages:</h4>\n<ul>\n<li>Decoupling: The ProductList class is no longer coupled to a specific loop syntax. The displayProducts method can use a for-each loop, a while loop, or any other iteration mechanism.</li>\n<li>Reusability: The Iterator interface can be used to iterate over various collections, not just product lists. This promotes code reuse and reduces redundancy.</li>\n<li>Open/Closed Principle: New collection types can be introduced without modifying existing code that uses iterators.</li>\n</ul>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Iterator</strong></li>\n<li><strong>Concrete Iterator</strong></li>\n<li><strong>Aggregate</strong></li>\n<li><strong>Concrete Aggregate</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*f9BfmdTGkI1ZVx3cRszlEg.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h4>When to Use the Iterator\u00a0Pattern</h4>\n<ul>\n<li>You want to hide the internal structure of a collection from the client\u00a0code.</li>\n<li>You need to provide a uniform way to iterate over different collection types.</li>\n<li>Your application needs to support custom iteration logic beyond the built-in for-each\u00a0loops.</li>\n</ul>\n<h4><strong>Real-World Applications:</strong></h4>\n<ul>\n<li>Java\u2019s Iterator interface and its implementations.</li>\n<li>Standard Template Library (STL) iterators in\u00a0C++.</li>\n<li>Database cursors.</li>\n<li>File system iterators.</li>\n</ul>\n<p>By understanding and effectively applying the Iterator Pattern, you can create more elegant, adaptable, and efficient software\u00a0systems.</p>\n<h4><strong>Additional Considerations:</strong></h4>\n<ul>\n<li>\n<strong>Performance:</strong> While the Iterator Pattern offers flexibility, it might introduce slight performance overhead compared to direct access in some\u00a0cases.</li>\n<li>\n<strong>Complexity:</strong> For simple collections, the Iterator Pattern might seem like overkill. Weigh the benefits against the added complexity in your specific use\u00a0case.</li>\n<li>\n<strong>Custom Iterators:</strong> Consider creating custom iterators for specific traversal needs, such as filtering or sorting elements during iteration.</li>\n</ul>\n<h4><strong>Exercise:</strong></h4>\n<p>Implement an iterator for a custom data structure, such as a tree or a graph. Explore different traversal strategies (e.g., depth-first, breadth-first) using the iterator interface.</p>\n<h3>Conclusion</h3>\n<p>The Iterator Pattern is a cornerstone of object-oriented programming, providing a standardized approach to traversing elements within collections. By encapsulating the iteration logic, it enhances code flexibility, maintainability, and reusability.</p>\n<p>By mastering the Iterator Pattern, you\u2019ll take a significant step towards building well-structured and maintainable software.</p>\n<p><strong>Join me tomorrow for Day 19 as we delve into the Mediator Pattern, a powerful mechanism for managing dependencies between\u00a0objects.</strong></p>\n<p>Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0\ud83d\udc4f!</p>\n<h3><strong>References:</strong></h3>\n<ul>\n<li>Head First Design Patterns\u00a0(Book)</li>\n<li><a href=\"https://refactoring.guru/design-patterns/iterator\">Refactoring Guru. (n.d.). Iterator\u00a0Pattern.</a></li>\n<li><a href=\"https://www.educative.io/courses/software-design-patterns-best-practices/iterator-pattern\">Educative. (n.d.). Learn to\u00a0Code.</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Iterator_pattern\">Wikipedia contributors. (n.d.). Iterator\u00a0pattern.</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/iterator-pattern/\">GeeksforGeeks. (n.d.). Iterator\u00a0Pattern.</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=24617aaff868\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Day 18: Iterator Pattern\u200a\u2014\u200aAccessing Elements Without Exposing the Underlying Structure</h3>\n<h3>Introduction</h3>\n<p>Welcome back, design pattern enthusiasts! Yesterday, we delved into the Command Pattern, a powerful tool for encapsulating requests and decoupling them from execution. Today, on <strong>Day 18</strong> of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>, we\u2019ll explore the <strong>Iterator Pattern</strong>. <em>This pattern provides a way to access the elements of an object collection without exposing its underlying internal structure.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/420/1*poltliMcDDCW029Eun3Nhg.png\"><figcaption>From refactoring.guru</figcaption></figure><h3>Problem</h3>\n<p>Imagine you\u2019re building an e-commerce website. Your website needs to display a list of products to users. This list could be implemented using an array, a linked list, or even a custom data structure. However, the specific implementation details shouldn\u2019t matter to the code that displays the products.</p>\n<p>Here\u2019s a simplified example of a product list implemented as an\u00a0array:</p>\n<pre>public class ProductList {<br>  private Product[] products;<br><br>  public ProductList(Product[] products) {<br>    this.products = products;<br>  }<br><br>  public void displayProducts() {<br>    for (Product product : products) {<br>      System.out.println(product.getName());<br>    }<br>  }<br>}</pre>\n<p>While this code works, it tightly couples the ProductList class with the for-each loop syntax. If we decide to change the underlying implementation to a linked list or a custom data structure, we'd need to modify the displayProducts method as well. This can be inconvenient and error-prone.</p>\n<h3>Solution</h3>\n<p>The Iterator Pattern introduces an Iterator interface that specifies a contract for iterating over the elements of a collection. This interface typically has a hasNext() method to check if there are more elements in the collection and a next() method to retrieve the next\u00a0element.</p>\n<p>Here\u2019s how the ProductList class can be refactored using the Iterator\u00a0Pattern:</p>\n<pre>public class ProductList {<br>  private List&lt;Product&gt; products;<br><br>  public ProductList(List&lt;Product&gt; products) {<br>    this.products = products;<br>  }<br><br>  public Iterator&lt;Product&gt; getIterator() {<br>    return new ProductListIterator(this.products);<br>  }<br>}<br><br>public interface Iterator&lt;T&gt; {<br>  boolean hasNext();<br><br>  T next();<br>}<br><br>public class ProductListIterator implements Iterator&lt;Product&gt; {<br>  private List&lt;Product&gt; products;<br>  private int currentPosition;<br><br>  public ProductListIterator(List&lt;Product&gt; products) {<br>    this.products = products;<br>    this.currentPosition = 0;<br>  }<br><br>  @Override<br>  public boolean hasNext() {<br>    return currentPosition &lt; products.size();<br>  }<br><br>  @Override<br>  public Product next() {<br>    if (hasNext()) {<br>      return products.get(currentPosition++);<br>    } else {<br>      throw new NoSuchElementException();<br>    }<br>  }<br>}</pre>\n<p>Now, the ProductList class provides a getIterator method that returns an Iterator object. The displayProducts method can be rewritten to use this iterator:</p>\n<pre>public void displayProducts() {<br>  Iterator&lt;Product&gt; iterator = getIterator();<br>  while (iterator.hasNext()) {<br>    Product product = iterator.next();<br>    System.out.println(product.getName());<br>  }<br>}</pre>\n<h4>This approach offers several advantages:</h4>\n<ul>\n<li>Decoupling: The ProductList class is no longer coupled to a specific loop syntax. The displayProducts method can use a for-each loop, a while loop, or any other iteration mechanism.</li>\n<li>Reusability: The Iterator interface can be used to iterate over various collections, not just product lists. This promotes code reuse and reduces redundancy.</li>\n<li>Open/Closed Principle: New collection types can be introduced without modifying existing code that uses iterators.</li>\n</ul>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Iterator</strong></li>\n<li><strong>Concrete Iterator</strong></li>\n<li><strong>Aggregate</strong></li>\n<li><strong>Concrete Aggregate</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*f9BfmdTGkI1ZVx3cRszlEg.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h4>When to Use the Iterator\u00a0Pattern</h4>\n<ul>\n<li>You want to hide the internal structure of a collection from the client\u00a0code.</li>\n<li>You need to provide a uniform way to iterate over different collection types.</li>\n<li>Your application needs to support custom iteration logic beyond the built-in for-each\u00a0loops.</li>\n</ul>\n<h4><strong>Real-World Applications:</strong></h4>\n<ul>\n<li>Java\u2019s Iterator interface and its implementations.</li>\n<li>Standard Template Library (STL) iterators in\u00a0C++.</li>\n<li>Database cursors.</li>\n<li>File system iterators.</li>\n</ul>\n<p>By understanding and effectively applying the Iterator Pattern, you can create more elegant, adaptable, and efficient software\u00a0systems.</p>\n<h4><strong>Additional Considerations:</strong></h4>\n<ul>\n<li>\n<strong>Performance:</strong> While the Iterator Pattern offers flexibility, it might introduce slight performance overhead compared to direct access in some\u00a0cases.</li>\n<li>\n<strong>Complexity:</strong> For simple collections, the Iterator Pattern might seem like overkill. Weigh the benefits against the added complexity in your specific use\u00a0case.</li>\n<li>\n<strong>Custom Iterators:</strong> Consider creating custom iterators for specific traversal needs, such as filtering or sorting elements during iteration.</li>\n</ul>\n<h4><strong>Exercise:</strong></h4>\n<p>Implement an iterator for a custom data structure, such as a tree or a graph. Explore different traversal strategies (e.g., depth-first, breadth-first) using the iterator interface.</p>\n<h3>Conclusion</h3>\n<p>The Iterator Pattern is a cornerstone of object-oriented programming, providing a standardized approach to traversing elements within collections. By encapsulating the iteration logic, it enhances code flexibility, maintainability, and reusability.</p>\n<p>By mastering the Iterator Pattern, you\u2019ll take a significant step towards building well-structured and maintainable software.</p>\n<p><strong>Join me tomorrow for Day 19 as we delve into the Mediator Pattern, a powerful mechanism for managing dependencies between\u00a0objects.</strong></p>\n<p>Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0\ud83d\udc4f!</p>\n<h3><strong>References:</strong></h3>\n<ul>\n<li>Head First Design Patterns\u00a0(Book)</li>\n<li><a href=\"https://refactoring.guru/design-patterns/iterator\">Refactoring Guru. (n.d.). Iterator\u00a0Pattern.</a></li>\n<li><a href=\"https://www.educative.io/courses/software-design-patterns-best-practices/iterator-pattern\">Educative. (n.d.). Learn to\u00a0Code.</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Iterator_pattern\">Wikipedia contributors. (n.d.). Iterator\u00a0pattern.</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/iterator-pattern/\">GeeksforGeeks. (n.d.). Iterator\u00a0Pattern.</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=24617aaff868\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["app-development","oop-concepts","design-patterns","iterator-pattern","software-development"]},{"title":"Day 17: Command Pattern\u200a\u2014\u200aTaking Orders and Executing Them Efficiently","pubDate":"2024-08-02 15:40:25","link":"https://sourabhkr.medium.com/day-17-command-pattern-taking-orders-and-executing-them-efficiently-91262cc35528?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/91262cc35528","author":"Sourabh Kumar","thumbnail":"","description":"\n<h3>Day 17: Command Pattern\u200a\u2014\u200aTaking Orders and Executing Them Efficiently</h3>\n<h3><strong>Introduction</strong></h3>\n<p>Welcome back, design pattern enthusiasts! Yesterday, we explored the Interpreter Pattern, empowering programs to understand external languages. Today, on <strong>Day 17</strong> of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>, we\u2019ll dive into the <strong>Command Pattern</strong>. <em>This pattern offers a powerful way to encapsulate a request as an object, allowing for flexible queuing, logging, and undo/redo functionalities.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/770/1*017b7t-28TzHysro1Z85tg.png\"></figure><h3>Problem</h3>\n<p>Imagine you\u2019re developing a smart home system. Your task is to create a control panel with buttons for various operations, like turning lights on and off, adjusting the thermostat, and locking doors. You create a sleek Button class that can be used for buttons on the control panel, as well as for generic buttons in other parts of the app, like mobile or web interfaces.</p>\n<p>All buttons in the app inherit from this base class. While they all look similar, each button needs to perform different actions. The simplest solution is to create many subclasses for each button, where each subclass contains the code to execute on a button\u00a0click.</p>\n<h4><strong>Lots of button subclasses. What can go\u00a0wrong?</strong></h4>\n<p>Before long, you realize this approach is flawed. First, you end up with a huge number of subclasses, and making any change to the base Button class risks breaking the subclasses. Your GUI code becomes awkwardly dependent on the volatile business logic\u00a0code.</p>\n<h4>Several classes implement the same functionality.</h4>\n<p>Some operations, like turning the lights on, need to be invoked from multiple places. For instance, you could click a small \u201cLight On\u201d button on the control panel, use a voice command via a smart speaker, or press a button on your mobile\u00a0app.</p>\n<p>Initially, when your app only had the control panel, it was okay to place the code for turning the lights on inside the LightOnButton subclass. But later, when you implement voice commands and mobile app buttons, you either have to duplicate the operation's code in many classes or make different interfaces dependent on the button subclasses, which is even\u00a0worse.</p>\n<h3>Solution</h3>\n<p><strong><em>Good software design often follows the principle of separation of concerns, breaking an app into layers.</em></strong> A typical example is having one layer for the graphical user interface (GUI) and another for the business logic. The GUI layer is responsible for displaying information on the screen and capturing user input. When it comes to performing important actions, like adjusting the thermostat or locking the doors, the GUI layer delegates the work to the underlying business logic\u00a0layer.</p>\n<p>In code, this might look like a GUI object calling a method of a business logic object, passing some arguments. This process is described as one object sending another a\u00a0request.</p>\n<p><strong>The Command pattern</strong> suggests that GUI objects shouldn\u2019t send requests directly. Instead, you should extract all request details (such as the target object, method name, and arguments) into a separate command class with a single method that triggers the\u00a0request.</p>\n<p>Command objects act as links between GUI and business logic objects. The GUI object doesn\u2019t need to know what business logic object will handle the request or how it will be processed. It just triggers the command, which manages all the\u00a0details.</p>\n<p>Next, make your commands implement the same interface, usually with a single execute method that takes no parameters. This interface lets you use various commands with the same request sender without coupling it to concrete command classes. As a bonus, you can switch command objects linked to the sender, effectively changing the sender\u2019s behavior at\u00a0runtime.</p>\n<p>You might wonder about request parameters. Since the command execute method doesn\u2019t take parameters, how would you pass the request details to the receiver? The command should be either pre-configured with this data or capable of retrieving it on its\u00a0own.</p>\n<h4>Applying the Command\u00a0Pattern</h4>\n<p>In our smart home system, after applying the Command pattern, you no longer need numerous button subclasses for different behaviors. Instead, put a single field in the base Button class to store a reference to a command object and make the button execute that command on a\u00a0click.</p>\n<p>You\u2019ll implement various command classes for every possible operation and link them with specific buttons based on their intended behavior.</p>\n<p>Other GUI elements, such as voice commands or mobile app buttons, can be implemented similarly. They\u2019ll be linked to a command which gets executed when the user interacts with the GUI element. Elements related to the same operations will be linked to the same commands, preventing code duplication.</p>\n<p>As a result, commands form a convenient middle layer that reduces coupling between the GUI and business logic layers. And that\u2019s just one of the many benefits the Command pattern\u00a0offers!</p>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li>\n<strong>Command:</strong> This interface (or abstract class) defines the execution contract for all commands. It typically has an execute() method that performs the specific\u00a0action.</li>\n<li>\n<strong>Concrete Command:</strong> These classes implement the Command interface and encapsulate the logic for a specific\u00a0action.</li>\n<li>\n<strong>Invoker:</strong> This object holds and executes the Command objects. It can be a button, menu item, or any entity that triggers an\u00a0action.</li>\n<li>\n<strong>Receiver:</strong> This object actually performs the work upon receiving the command. It can be a separate class representing the functionality to be executed.</li>\n<li>\n<strong>Client:</strong> This object creates concrete command objects and sets the receiver. It then passes the command to the invoker for execution.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*nEHMNMsJSc40n_3SBV2o_w.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h3><strong>Implementation Example</strong></h3>\n<p>Let\u2019s illustrate the Command Pattern with a simple light switch\u00a0example.</p>\n<pre>interface Command {<br>  void execute();<br>}<br><br>class Light {<br>  public void turnOn() {<br>    System.out.println(\"Light turned on\");<br>  }<br><br>  public void turnOff() {<br>    System.out.println(\"Light turned off\");<br>  }<br>}<br><br>class LightOnCommand implements Command {<br>  private Light light;<br><br>  public LightOnCommand(Light light) {<br>    this.light = light;<br>  }<br><br>  @Override<br>  public void execute() {<br>    light.turnOn();<br>  }<br>}<br><br>class LightOffCommand implements Command {<br>  private Light light;<br><br>  public LightOffCommand(Light light) {<br>    this.light = light;<br>  }<br><br>  @Override<br>  public void execute() {<br>    light.turnOff();<br>  }<br>}<br><br>class Switch {<br>  private Command command;<br><br>  public void setCommand(Command command) {<br>    this.command = command;<br>  }<br><br>  public void press() {<br>    if (command != null) {<br>      command.execute();<br>    }<br>  }<br>}</pre>\n<h4>Benefits of the Command\u00a0Pattern</h4>\n<ul>\n<li>\n<strong>Decoupling:</strong> Separates the request from the execution, promoting loose coupling and flexibility.</li>\n<li>\n<strong>Queuing:</strong> Commands can be queued for later execution or batched for efficient processing.</li>\n<li>\n<strong>Undo/Redo:</strong> Commands can be stored and replayed to implement undo/redo functionalities.</li>\n<li>\n<strong>Logging:</strong> Commands can be logged for auditing or debugging purposes.</li>\n<li>\n<strong>Macro Creation:</strong> Allows grouping multiple commands into a single macro for complex operations.</li>\n</ul>\n<h4><strong>When to Use the Command\u00a0Pattern</strong></h4>\n<ul>\n<li>You need to decouple the request from the execution.</li>\n<li>You want to support queuing, logging, or undo/redo functionalities for\u00a0actions.</li>\n<li>Your system benefits from the ability to create macros or composite commands.</li>\n</ul>\n<h4><strong>Real-World Examples</strong></h4>\n<ul>\n<li>\n<strong>GUI Buttons and Menus:</strong> Buttons and menu items often trigger commands that interact with the application.</li>\n<li>\n<strong>Macros:</strong> Macros in software programs can be implemented using the Command\u00a0Pattern.</li>\n<li>\n<strong>Transaction Processing Systems:</strong> Commands can be used to represent transactions and ensure atomicity.</li>\n<li>java.lang.Runnable defines the interface implemented by classes whose instances are executed by\u00a0threads.</li>\n<li>Implementations of javax.swing.Action also conform to the command\u00a0pattern.</li>\n</ul>\n<h3><strong>Conclusion</strong></h3>\n<p>The Command Pattern emerges as a versatile tool in a software developer\u2019s arsenal, offering a structured approach to encapsulating and managing requests. By decoupling the request from its execution, you create systems that are more flexible, extensible, and maintainable. Whether you need to support undo/redo functionalities, queuing, or complex macro actions, the Command Pattern provides a robust foundation.</p>\n<p>By mastering this pattern, you\u2019ll gain the ability to design systems that are not only efficient but also adaptable to evolving requirements. So, embrace the power of the Command Pattern and elevate your software development practices!</p>\n<p>Join me tomorrow as we explore another essential design pattern on our journey. Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0\ud83d\udc4f!</p>\n<p><strong><em>Stay tuned for Day\u00a018!</em></strong></p>\n<h4><strong>References</strong></h4>\n<ul>\n<li>Head First Design Patterns\u00a0(Book)</li>\n<li>\n<a href=\"https://refactoring.guru/design-patterns/command\">Refactoring Guru. (n.d.). Command\u00a0Pattern</a>.</li>\n<li><a href=\"https://www.educative.io/courses/software-design-patterns-best-practices/command-pattern\">Educative. (n.d.). Learn to\u00a0Code.</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Command_pattern\">Wikipedia contributors. (n.d.). Command\u00a0pattern.</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/command-pattern/\">GeeksforGeeks. (n.d.). Command\u00a0Pattern.</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=91262cc35528\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Day 17: Command Pattern\u200a\u2014\u200aTaking Orders and Executing Them Efficiently</h3>\n<h3><strong>Introduction</strong></h3>\n<p>Welcome back, design pattern enthusiasts! Yesterday, we explored the Interpreter Pattern, empowering programs to understand external languages. Today, on <strong>Day 17</strong> of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>, we\u2019ll dive into the <strong>Command Pattern</strong>. <em>This pattern offers a powerful way to encapsulate a request as an object, allowing for flexible queuing, logging, and undo/redo functionalities.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/770/1*017b7t-28TzHysro1Z85tg.png\"></figure><h3>Problem</h3>\n<p>Imagine you\u2019re developing a smart home system. Your task is to create a control panel with buttons for various operations, like turning lights on and off, adjusting the thermostat, and locking doors. You create a sleek Button class that can be used for buttons on the control panel, as well as for generic buttons in other parts of the app, like mobile or web interfaces.</p>\n<p>All buttons in the app inherit from this base class. While they all look similar, each button needs to perform different actions. The simplest solution is to create many subclasses for each button, where each subclass contains the code to execute on a button\u00a0click.</p>\n<h4><strong>Lots of button subclasses. What can go\u00a0wrong?</strong></h4>\n<p>Before long, you realize this approach is flawed. First, you end up with a huge number of subclasses, and making any change to the base Button class risks breaking the subclasses. Your GUI code becomes awkwardly dependent on the volatile business logic\u00a0code.</p>\n<h4>Several classes implement the same functionality.</h4>\n<p>Some operations, like turning the lights on, need to be invoked from multiple places. For instance, you could click a small \u201cLight On\u201d button on the control panel, use a voice command via a smart speaker, or press a button on your mobile\u00a0app.</p>\n<p>Initially, when your app only had the control panel, it was okay to place the code for turning the lights on inside the LightOnButton subclass. But later, when you implement voice commands and mobile app buttons, you either have to duplicate the operation's code in many classes or make different interfaces dependent on the button subclasses, which is even\u00a0worse.</p>\n<h3>Solution</h3>\n<p><strong><em>Good software design often follows the principle of separation of concerns, breaking an app into layers.</em></strong> A typical example is having one layer for the graphical user interface (GUI) and another for the business logic. The GUI layer is responsible for displaying information on the screen and capturing user input. When it comes to performing important actions, like adjusting the thermostat or locking the doors, the GUI layer delegates the work to the underlying business logic\u00a0layer.</p>\n<p>In code, this might look like a GUI object calling a method of a business logic object, passing some arguments. This process is described as one object sending another a\u00a0request.</p>\n<p><strong>The Command pattern</strong> suggests that GUI objects shouldn\u2019t send requests directly. Instead, you should extract all request details (such as the target object, method name, and arguments) into a separate command class with a single method that triggers the\u00a0request.</p>\n<p>Command objects act as links between GUI and business logic objects. The GUI object doesn\u2019t need to know what business logic object will handle the request or how it will be processed. It just triggers the command, which manages all the\u00a0details.</p>\n<p>Next, make your commands implement the same interface, usually with a single execute method that takes no parameters. This interface lets you use various commands with the same request sender without coupling it to concrete command classes. As a bonus, you can switch command objects linked to the sender, effectively changing the sender\u2019s behavior at\u00a0runtime.</p>\n<p>You might wonder about request parameters. Since the command execute method doesn\u2019t take parameters, how would you pass the request details to the receiver? The command should be either pre-configured with this data or capable of retrieving it on its\u00a0own.</p>\n<h4>Applying the Command\u00a0Pattern</h4>\n<p>In our smart home system, after applying the Command pattern, you no longer need numerous button subclasses for different behaviors. Instead, put a single field in the base Button class to store a reference to a command object and make the button execute that command on a\u00a0click.</p>\n<p>You\u2019ll implement various command classes for every possible operation and link them with specific buttons based on their intended behavior.</p>\n<p>Other GUI elements, such as voice commands or mobile app buttons, can be implemented similarly. They\u2019ll be linked to a command which gets executed when the user interacts with the GUI element. Elements related to the same operations will be linked to the same commands, preventing code duplication.</p>\n<p>As a result, commands form a convenient middle layer that reduces coupling between the GUI and business logic layers. And that\u2019s just one of the many benefits the Command pattern\u00a0offers!</p>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li>\n<strong>Command:</strong> This interface (or abstract class) defines the execution contract for all commands. It typically has an execute() method that performs the specific\u00a0action.</li>\n<li>\n<strong>Concrete Command:</strong> These classes implement the Command interface and encapsulate the logic for a specific\u00a0action.</li>\n<li>\n<strong>Invoker:</strong> This object holds and executes the Command objects. It can be a button, menu item, or any entity that triggers an\u00a0action.</li>\n<li>\n<strong>Receiver:</strong> This object actually performs the work upon receiving the command. It can be a separate class representing the functionality to be executed.</li>\n<li>\n<strong>Client:</strong> This object creates concrete command objects and sets the receiver. It then passes the command to the invoker for execution.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*nEHMNMsJSc40n_3SBV2o_w.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h3><strong>Implementation Example</strong></h3>\n<p>Let\u2019s illustrate the Command Pattern with a simple light switch\u00a0example.</p>\n<pre>interface Command {<br>  void execute();<br>}<br><br>class Light {<br>  public void turnOn() {<br>    System.out.println(\"Light turned on\");<br>  }<br><br>  public void turnOff() {<br>    System.out.println(\"Light turned off\");<br>  }<br>}<br><br>class LightOnCommand implements Command {<br>  private Light light;<br><br>  public LightOnCommand(Light light) {<br>    this.light = light;<br>  }<br><br>  @Override<br>  public void execute() {<br>    light.turnOn();<br>  }<br>}<br><br>class LightOffCommand implements Command {<br>  private Light light;<br><br>  public LightOffCommand(Light light) {<br>    this.light = light;<br>  }<br><br>  @Override<br>  public void execute() {<br>    light.turnOff();<br>  }<br>}<br><br>class Switch {<br>  private Command command;<br><br>  public void setCommand(Command command) {<br>    this.command = command;<br>  }<br><br>  public void press() {<br>    if (command != null) {<br>      command.execute();<br>    }<br>  }<br>}</pre>\n<h4>Benefits of the Command\u00a0Pattern</h4>\n<ul>\n<li>\n<strong>Decoupling:</strong> Separates the request from the execution, promoting loose coupling and flexibility.</li>\n<li>\n<strong>Queuing:</strong> Commands can be queued for later execution or batched for efficient processing.</li>\n<li>\n<strong>Undo/Redo:</strong> Commands can be stored and replayed to implement undo/redo functionalities.</li>\n<li>\n<strong>Logging:</strong> Commands can be logged for auditing or debugging purposes.</li>\n<li>\n<strong>Macro Creation:</strong> Allows grouping multiple commands into a single macro for complex operations.</li>\n</ul>\n<h4><strong>When to Use the Command\u00a0Pattern</strong></h4>\n<ul>\n<li>You need to decouple the request from the execution.</li>\n<li>You want to support queuing, logging, or undo/redo functionalities for\u00a0actions.</li>\n<li>Your system benefits from the ability to create macros or composite commands.</li>\n</ul>\n<h4><strong>Real-World Examples</strong></h4>\n<ul>\n<li>\n<strong>GUI Buttons and Menus:</strong> Buttons and menu items often trigger commands that interact with the application.</li>\n<li>\n<strong>Macros:</strong> Macros in software programs can be implemented using the Command\u00a0Pattern.</li>\n<li>\n<strong>Transaction Processing Systems:</strong> Commands can be used to represent transactions and ensure atomicity.</li>\n<li>java.lang.Runnable defines the interface implemented by classes whose instances are executed by\u00a0threads.</li>\n<li>Implementations of javax.swing.Action also conform to the command\u00a0pattern.</li>\n</ul>\n<h3><strong>Conclusion</strong></h3>\n<p>The Command Pattern emerges as a versatile tool in a software developer\u2019s arsenal, offering a structured approach to encapsulating and managing requests. By decoupling the request from its execution, you create systems that are more flexible, extensible, and maintainable. Whether you need to support undo/redo functionalities, queuing, or complex macro actions, the Command Pattern provides a robust foundation.</p>\n<p>By mastering this pattern, you\u2019ll gain the ability to design systems that are not only efficient but also adaptable to evolving requirements. So, embrace the power of the Command Pattern and elevate your software development practices!</p>\n<p>Join me tomorrow as we explore another essential design pattern on our journey. Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0\ud83d\udc4f!</p>\n<p><strong><em>Stay tuned for Day\u00a018!</em></strong></p>\n<h4><strong>References</strong></h4>\n<ul>\n<li>Head First Design Patterns\u00a0(Book)</li>\n<li>\n<a href=\"https://refactoring.guru/design-patterns/command\">Refactoring Guru. (n.d.). Command\u00a0Pattern</a>.</li>\n<li><a href=\"https://www.educative.io/courses/software-design-patterns-best-practices/command-pattern\">Educative. (n.d.). Learn to\u00a0Code.</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Command_pattern\">Wikipedia contributors. (n.d.). Command\u00a0pattern.</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/command-pattern/\">GeeksforGeeks. (n.d.). Command\u00a0Pattern.</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=91262cc35528\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["design-patterns","system-design-interview","command-pattern","java","object-oriented"]},{"title":"Day 16: Interpreter Pattern: Making Computers Speak Our Language","pubDate":"2024-08-01 14:01:50","link":"https://sourabhkr.medium.com/day-16-interpreter-pattern-making-computers-speak-our-language-dbd664e56828?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/dbd664e56828","author":"Sourabh Kumar","thumbnail":"","description":"\n<h3>Introduction</h3>\n<p>Welcome back, fellow design pattern enthusiasts! Today, on <strong>Day 16</strong> of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>, we\u2019ll explore the <strong>Interpreter Pattern</strong>. <em>This pattern empowers programs to interpret an external language and execute corresponding actions.</em> Buckle up as we unlock the secrets of transforming external instructions into <strong>computer-understandable code</strong>!</p>\n<h4>Understanding the Interpreter Pattern</h4>\n<p>Imagine a robot programmed to follow a set of instructions. These instructions could be written in a simple language like \u201cmove forward 10 steps\u201d or \u201cturn left 90 degrees.\u201d The Interpreter Pattern provides a framework for translating these external instructions (the language) into actions the robot (the program) can understand and\u00a0execute.</p>\n<h4>Core Components</h4>\n<ul>\n<li>\n<strong>Interpreter:</strong> This object plays a crucial role in deciphering the external language. It defines a set of interpretation methods, each responsible for handling a specific type of instruction.</li>\n<li>\n<strong>Expression:</strong> This interface (or abstract class) represents a single instruction within the external language. Concrete expressions implement this interface and provide a way to interpret themselves using the interpreter.</li>\n<li>\n<strong>Terminal Expression:</strong> This concrete class represents a basic instruction in the language. It implements the Expression interface and defines its interpretation logic.</li>\n<li>\n<strong>Non-Terminal Expression:</strong> This concrete class represents a more complex instruction composed of other expressions. It implements the Expression interface and interprets itself by calling the interpretation methods of its constituent expressions.</li>\n</ul>\n<h4>Benefits of the Interpreter Pattern</h4>\n<ul>\n<li>\n<strong>Flexibility:</strong> New instructions can be added to the language by creating new Expression classes without modifying the interpreter itself.</li>\n<li>\n<strong>Security:</strong> The interpreter acts as a controlled gateway, ensuring only valid instructions are processed.</li>\n<li>\n<strong>Maintainability:</strong> Separating the interpretation logic from the core program improves code clarity and reduces complexity.</li>\n</ul>\n<h4>Class Diagram</h4>\n<ul>\n<li><strong>Abstract Expression</strong></li>\n<li><strong>Terminal Expression</strong></li>\n<li><strong>Nonterminal Expression</strong></li>\n<li><strong>Context</strong></li>\n<li><strong>Client</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*V0x9jWX-0BLL1CkV22ef0g.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h4><strong>Implementation Example</strong></h4>\n<p>Let\u2019s illustrate the Interpreter Pattern with a simple calculator that evaluates arithmetic expressions.</p>\n<pre>interface Expression {<br>  int interpret(Context context);<br>}<br><br>class Context {<br>  private int value;<br><br>  public void setValue(int value) {<br>    this.value = value;<br>  }<br>}<br><br>class TerminalExpression implements Expression {<br>  private int value;<br><br>  public TerminalExpression(int value) {<br>    this.value = value;<br>  }<br><br>  @Override<br>  public int interpret(Context context) {<br>    return value;<br>  }<br>}<br><br>class NonTerminalExpression implements Expression {<br>  private char operator;<br>  private Expression left, right;<br><br>  public NonTerminalExpression(char operator, Expression left, Expression right) {<br>    this.operator = operator;<br>    this.left = left;<br>    this.right = right;<br>  }<br><br>  @Override<br>  public int interpret(Context context) {<br>    switch (operator) {<br>      case '+':<br>        return left.interpret(context) + right.interpret(context);<br>      case '-':<br>        return left.interpret(context) - right.interpret(context);<br>      default:<br>        return 0;<br>    }<br>  }<br>}<br><br>class Interpreter {<br>  private Expression expression;<br><br>  public Interpreter(Expression expression) {<br>    this.expression = expression;<br>  }<br><br>  public int evaluate(Context context) {<br>    return expression.interpret(context);<br>  }<br>}</pre>\n<h4><strong>When to Use the Interpreter Pattern</strong></h4>\n<ul>\n<li>You need to process data in a custom language specific to your\u00a0domain.</li>\n<li>You want to define a grammar for a mini-language and execute programs written in that language.</li>\n<li>The system needs to support the extension of the language with new instructions.</li>\n</ul>\n<h4><strong>Real-World Examples</strong></h4>\n<ul>\n<li>\n<strong>Compilers:</strong> Translate high-level programming languages into machine\u00a0code.</li>\n<li>\n<strong>Spreadsheets:</strong> Interpret formulas entered by users and calculate the\u00a0results.</li>\n<li>\n<strong>Expression Engines:</strong> Evaluate expressions in query languages or configuration files.</li>\n<li>java.util.Pattern is a compiled representation of a regular expression.</li>\n<li>java.text.Normalizer provides functionality to transform Unicode\u00a0text.</li>\n</ul>\n<h4><strong>Conclusion</strong></h4>\n<p>The Interpreter Pattern provides a powerful approach for bridging the gap between external languages and internal program logic. By separating interpretation concerns, you can create flexible and maintainable systems that can adapt to new languages and instructions.</p>\n<p><strong>Stay tuned for tomorrow\u2019s post, where we\u2019ll delve into the fascinating world of the Command\u00a0Pattern!</strong></p>\n<p>Join me on this <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-day adventure</strong></a> as we conquer the world of design patterns together! Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a<strong>\u00a0</strong>clap\ud83d\udc4f!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=dbd664e56828\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Introduction</h3>\n<p>Welcome back, fellow design pattern enthusiasts! Today, on <strong>Day 16</strong> of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>, we\u2019ll explore the <strong>Interpreter Pattern</strong>. <em>This pattern empowers programs to interpret an external language and execute corresponding actions.</em> Buckle up as we unlock the secrets of transforming external instructions into <strong>computer-understandable code</strong>!</p>\n<h4>Understanding the Interpreter Pattern</h4>\n<p>Imagine a robot programmed to follow a set of instructions. These instructions could be written in a simple language like \u201cmove forward 10 steps\u201d or \u201cturn left 90 degrees.\u201d The Interpreter Pattern provides a framework for translating these external instructions (the language) into actions the robot (the program) can understand and\u00a0execute.</p>\n<h4>Core Components</h4>\n<ul>\n<li>\n<strong>Interpreter:</strong> This object plays a crucial role in deciphering the external language. It defines a set of interpretation methods, each responsible for handling a specific type of instruction.</li>\n<li>\n<strong>Expression:</strong> This interface (or abstract class) represents a single instruction within the external language. Concrete expressions implement this interface and provide a way to interpret themselves using the interpreter.</li>\n<li>\n<strong>Terminal Expression:</strong> This concrete class represents a basic instruction in the language. It implements the Expression interface and defines its interpretation logic.</li>\n<li>\n<strong>Non-Terminal Expression:</strong> This concrete class represents a more complex instruction composed of other expressions. It implements the Expression interface and interprets itself by calling the interpretation methods of its constituent expressions.</li>\n</ul>\n<h4>Benefits of the Interpreter Pattern</h4>\n<ul>\n<li>\n<strong>Flexibility:</strong> New instructions can be added to the language by creating new Expression classes without modifying the interpreter itself.</li>\n<li>\n<strong>Security:</strong> The interpreter acts as a controlled gateway, ensuring only valid instructions are processed.</li>\n<li>\n<strong>Maintainability:</strong> Separating the interpretation logic from the core program improves code clarity and reduces complexity.</li>\n</ul>\n<h4>Class Diagram</h4>\n<ul>\n<li><strong>Abstract Expression</strong></li>\n<li><strong>Terminal Expression</strong></li>\n<li><strong>Nonterminal Expression</strong></li>\n<li><strong>Context</strong></li>\n<li><strong>Client</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*V0x9jWX-0BLL1CkV22ef0g.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h4><strong>Implementation Example</strong></h4>\n<p>Let\u2019s illustrate the Interpreter Pattern with a simple calculator that evaluates arithmetic expressions.</p>\n<pre>interface Expression {<br>  int interpret(Context context);<br>}<br><br>class Context {<br>  private int value;<br><br>  public void setValue(int value) {<br>    this.value = value;<br>  }<br>}<br><br>class TerminalExpression implements Expression {<br>  private int value;<br><br>  public TerminalExpression(int value) {<br>    this.value = value;<br>  }<br><br>  @Override<br>  public int interpret(Context context) {<br>    return value;<br>  }<br>}<br><br>class NonTerminalExpression implements Expression {<br>  private char operator;<br>  private Expression left, right;<br><br>  public NonTerminalExpression(char operator, Expression left, Expression right) {<br>    this.operator = operator;<br>    this.left = left;<br>    this.right = right;<br>  }<br><br>  @Override<br>  public int interpret(Context context) {<br>    switch (operator) {<br>      case '+':<br>        return left.interpret(context) + right.interpret(context);<br>      case '-':<br>        return left.interpret(context) - right.interpret(context);<br>      default:<br>        return 0;<br>    }<br>  }<br>}<br><br>class Interpreter {<br>  private Expression expression;<br><br>  public Interpreter(Expression expression) {<br>    this.expression = expression;<br>  }<br><br>  public int evaluate(Context context) {<br>    return expression.interpret(context);<br>  }<br>}</pre>\n<h4><strong>When to Use the Interpreter Pattern</strong></h4>\n<ul>\n<li>You need to process data in a custom language specific to your\u00a0domain.</li>\n<li>You want to define a grammar for a mini-language and execute programs written in that language.</li>\n<li>The system needs to support the extension of the language with new instructions.</li>\n</ul>\n<h4><strong>Real-World Examples</strong></h4>\n<ul>\n<li>\n<strong>Compilers:</strong> Translate high-level programming languages into machine\u00a0code.</li>\n<li>\n<strong>Spreadsheets:</strong> Interpret formulas entered by users and calculate the\u00a0results.</li>\n<li>\n<strong>Expression Engines:</strong> Evaluate expressions in query languages or configuration files.</li>\n<li>java.util.Pattern is a compiled representation of a regular expression.</li>\n<li>java.text.Normalizer provides functionality to transform Unicode\u00a0text.</li>\n</ul>\n<h4><strong>Conclusion</strong></h4>\n<p>The Interpreter Pattern provides a powerful approach for bridging the gap between external languages and internal program logic. By separating interpretation concerns, you can create flexible and maintainable systems that can adapt to new languages and instructions.</p>\n<p><strong>Stay tuned for tomorrow\u2019s post, where we\u2019ll delve into the fascinating world of the Command\u00a0Pattern!</strong></p>\n<p>Join me on this <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-day adventure</strong></a> as we conquer the world of design patterns together! Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a<strong>\u00a0</strong>clap\ud83d\udc4f!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=dbd664e56828\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["design-patterns","system-design-interview","java","interpreter-pattern","app-development"]},{"title":"Day 15: Observer Pattern: Keeping Everyone in the Loop","pubDate":"2024-07-31 23:23:43","link":"https://sourabhkr.medium.com/day-15-observer-pattern-keeping-everyone-in-the-loop-40e3f72e0d7e?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/40e3f72e0d7e","author":"Sourabh Kumar","thumbnail":"","description":"\n<h3><strong>Introduction</strong></h3>\n<p>Welcome back to <strong>day 15</strong> of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>! Today, we\u2019ll explore the <strong>Observer Pattern</strong>, <em>a fundamental concept for establishing communication between objects</em>. Buckle up as we delve into how this pattern facilitates a \u201c<strong>publish-subscribe</strong>\u201d model, keeping interested parties informed about\u00a0changes.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pg_tZ_5N3aF5plPsY_kC5Q.png\"><figcaption><em>Magazine and newspaper subscriptions. (r</em>efactoring.guru<em>)</em></figcaption></figure><h4><strong>Understanding the Observer\u00a0Pattern</strong></h4>\n<p>Imagine a news organization with various departments\u200a\u2014\u200asports, business, and technology. Whenever a breaking news story emerges, the editor (subject) needs to notify all relevant departments (observers) about the update. The Observer Pattern provides a structured approach for this notification process.</p>\n<h4><strong>Core Components</strong></h4>\n<ul>\n<li>\n<strong>Subject:</strong> The object that holds the data and manages the registered observers. It provides methods for observers to subscribe and unsubscribe to\u00a0updates.</li>\n<li>\n<strong>Observer:</strong> The object interested in receiving notifications from the subject. It implements an update method to be called whenever the subject\u2019s state\u00a0changes.</li>\n</ul>\n<h4><strong>Benefits of the Observer\u00a0Pattern</strong></h4>\n<ul>\n<li>\n<strong>Loose Coupling:</strong> The subject and observers are unaware of each other\u2019s concrete implementations. This promotes flexibility and maintainability.</li>\n<li>\n<strong>Decoupled Communication:</strong> Observers don\u2019t directly access the subject\u2019s state. They rely on the subject\u2019s notification mechanism.</li>\n<li>\n<strong>Dynamic Updates:</strong> New observers can be added or removed at runtime without affecting existing\u00a0code.</li>\n</ul>\n<h4><strong>Class Diagram</strong></h4>\n<ul>\n<li>Subject</li>\n<li>Observer (interface)</li>\n<li>Concrete Observers (extending Observer)</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ftZsqx8PA43dwvFoEeASfQ.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h4><strong>Implementation Example</strong></h4>\n<p>Let\u2019s illustrate the Observer Pattern with a simple weather monitoring system.</p>\n<pre>interface WeatherSubject {<br>  void registerObserver(WeatherObserver observer);<br>  void removeObserver(WeatherObserver observer);<br>  void notifyObservers();<br>}<br><br>class WeatherData implements WeatherSubject {<br>  private List&lt;WeatherObserver&gt; observers;<br>  private float temperature;<br>  private float humidity;<br>  private float pressure;<br><br>  // Implementation for registering, removing observers and notifying them<br>}<br><br>interface WeatherObserver {<br>  void update(float temperature, float humidity, float pressure);<br>}<br><br>class CurrentConditionsDisplay implements WeatherObserver {<br>  @Override<br>  public void update(float temperature, float humidity, float pressure) {<br>    System.out.println(\"Current Conditions: [Temp: \" + temperature + \" Humidity: \" + humidity + \" Pressure: \" + pressure + \"]\");<br>  }<br>}<br><br>public class ObserverDemo {<br>  public static void main(String[] args) {<br>    WeatherData weatherData = new WeatherData();<br>    CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay();<br><br>    weatherData.registerObserver(currentConditionsDisplay);<br><br>    weatherData.setMeasurements(25.0f, 70.0f, 1020.0f);<br>    weatherData.setMeasurements(30.0f, 60.0f, 1015.0f);<br>  }<br>}</pre>\n<h4>When to Use\u00a0the</h4>\n<ul>\n<li>You need a one-to-many dependency between objects, where changes in one object (subject) need to be reflected in multiple other objects (observers).</li>\n<li>You want a flexible and decoupled communication mechanism between\u00a0objects.</li>\n<li>The system needs to support dynamic addition or removal of observers.</li>\n</ul>\n<h4><strong>Real-World Examples</strong></h4>\n<ul>\n<li>\n<strong>GUI Toolkits:</strong> When a user interacts with a UI element (subject), it might notify other UI elements (observers) to update their appearance.</li>\n<li>\n<strong>Event Notification Systems:</strong> Messaging platforms or news feeds use the Observer Pattern to notify subscribed users about new\u00a0content.</li>\n<li>\n<strong>Dependency Management Systems:</strong> Build tools can leverage the Observer Pattern to inform dependent projects about changes in a\u00a0library.</li>\n</ul>\n<h4><strong>Conclusion</strong></h4>\n<p>The Observer Pattern is a cornerstone for building loosely coupled and reactive systems. By establishing clear communication channels between subjects and observers, you can create applications that effectively propagate changes and maintain consistency.</p>\n<p>Stay tuned for tomorrow\u2019s post, we\u2019ll dive into another behavioral pattern\u00a0: <strong>Interpreter Pattern</strong>.</p>\n<p>Join me on this <a href=\"https://medium.com/@sourabhkr/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-day adventure</strong></a> as we conquer the world of design patterns together! Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a\u00a0clap\ud83d\udc4f!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=40e3f72e0d7e\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3><strong>Introduction</strong></h3>\n<p>Welcome back to <strong>day 15</strong> of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>! Today, we\u2019ll explore the <strong>Observer Pattern</strong>, <em>a fundamental concept for establishing communication between objects</em>. Buckle up as we delve into how this pattern facilitates a \u201c<strong>publish-subscribe</strong>\u201d model, keeping interested parties informed about\u00a0changes.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pg_tZ_5N3aF5plPsY_kC5Q.png\"><figcaption><em>Magazine and newspaper subscriptions. (r</em>efactoring.guru<em>)</em></figcaption></figure><h4><strong>Understanding the Observer\u00a0Pattern</strong></h4>\n<p>Imagine a news organization with various departments\u200a\u2014\u200asports, business, and technology. Whenever a breaking news story emerges, the editor (subject) needs to notify all relevant departments (observers) about the update. The Observer Pattern provides a structured approach for this notification process.</p>\n<h4><strong>Core Components</strong></h4>\n<ul>\n<li>\n<strong>Subject:</strong> The object that holds the data and manages the registered observers. It provides methods for observers to subscribe and unsubscribe to\u00a0updates.</li>\n<li>\n<strong>Observer:</strong> The object interested in receiving notifications from the subject. It implements an update method to be called whenever the subject\u2019s state\u00a0changes.</li>\n</ul>\n<h4><strong>Benefits of the Observer\u00a0Pattern</strong></h4>\n<ul>\n<li>\n<strong>Loose Coupling:</strong> The subject and observers are unaware of each other\u2019s concrete implementations. This promotes flexibility and maintainability.</li>\n<li>\n<strong>Decoupled Communication:</strong> Observers don\u2019t directly access the subject\u2019s state. They rely on the subject\u2019s notification mechanism.</li>\n<li>\n<strong>Dynamic Updates:</strong> New observers can be added or removed at runtime without affecting existing\u00a0code.</li>\n</ul>\n<h4><strong>Class Diagram</strong></h4>\n<ul>\n<li>Subject</li>\n<li>Observer (interface)</li>\n<li>Concrete Observers (extending Observer)</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ftZsqx8PA43dwvFoEeASfQ.png\"><figcaption>Class Diagram (educative.io)</figcaption></figure><h4><strong>Implementation Example</strong></h4>\n<p>Let\u2019s illustrate the Observer Pattern with a simple weather monitoring system.</p>\n<pre>interface WeatherSubject {<br>  void registerObserver(WeatherObserver observer);<br>  void removeObserver(WeatherObserver observer);<br>  void notifyObservers();<br>}<br><br>class WeatherData implements WeatherSubject {<br>  private List&lt;WeatherObserver&gt; observers;<br>  private float temperature;<br>  private float humidity;<br>  private float pressure;<br><br>  // Implementation for registering, removing observers and notifying them<br>}<br><br>interface WeatherObserver {<br>  void update(float temperature, float humidity, float pressure);<br>}<br><br>class CurrentConditionsDisplay implements WeatherObserver {<br>  @Override<br>  public void update(float temperature, float humidity, float pressure) {<br>    System.out.println(\"Current Conditions: [Temp: \" + temperature + \" Humidity: \" + humidity + \" Pressure: \" + pressure + \"]\");<br>  }<br>}<br><br>public class ObserverDemo {<br>  public static void main(String[] args) {<br>    WeatherData weatherData = new WeatherData();<br>    CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay();<br><br>    weatherData.registerObserver(currentConditionsDisplay);<br><br>    weatherData.setMeasurements(25.0f, 70.0f, 1020.0f);<br>    weatherData.setMeasurements(30.0f, 60.0f, 1015.0f);<br>  }<br>}</pre>\n<h4>When to Use\u00a0the</h4>\n<ul>\n<li>You need a one-to-many dependency between objects, where changes in one object (subject) need to be reflected in multiple other objects (observers).</li>\n<li>You want a flexible and decoupled communication mechanism between\u00a0objects.</li>\n<li>The system needs to support dynamic addition or removal of observers.</li>\n</ul>\n<h4><strong>Real-World Examples</strong></h4>\n<ul>\n<li>\n<strong>GUI Toolkits:</strong> When a user interacts with a UI element (subject), it might notify other UI elements (observers) to update their appearance.</li>\n<li>\n<strong>Event Notification Systems:</strong> Messaging platforms or news feeds use the Observer Pattern to notify subscribed users about new\u00a0content.</li>\n<li>\n<strong>Dependency Management Systems:</strong> Build tools can leverage the Observer Pattern to inform dependent projects about changes in a\u00a0library.</li>\n</ul>\n<h4><strong>Conclusion</strong></h4>\n<p>The Observer Pattern is a cornerstone for building loosely coupled and reactive systems. By establishing clear communication channels between subjects and observers, you can create applications that effectively propagate changes and maintain consistency.</p>\n<p>Stay tuned for tomorrow\u2019s post, we\u2019ll dive into another behavioral pattern\u00a0: <strong>Interpreter Pattern</strong>.</p>\n<p>Join me on this <a href=\"https://medium.com/@sourabhkr/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-day adventure</strong></a> as we conquer the world of design patterns together! Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a\u00a0clap\ud83d\udc4f!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=40e3f72e0d7e\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["design-patterns","app-development","observer-pattern","java","system-design-interview"]},{"title":"Day 14: Chain of Responsibility Pattern: Passing the Buck","pubDate":"2024-07-30 20:19:55","link":"https://sourabhkr.medium.com/day-14-chain-of-responsibility-pattern-passing-the-buck-bd8b9264ec44?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/bd8b9264ec44","author":"Sourabh Kumar","thumbnail":"","description":"\n<h3>Introduction</h3>\n<p>Welcome to day 14 of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>! Today we dive into our first behavioral pattern: the <strong>Chain of Responsibility</strong>. <em>This pattern is all about creating a chain of objects to handle a request, passing it along until an object in the chain can process\u00a0it.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*mZzdmxAKcQSo4ALIPaY30A.png\"><figcaption><strong>Illustration by Frits Ahlefeldt</strong></figcaption></figure><h3>Understanding the Chain of Responsibility</h3>\n<p>Imagine a customer support system. A customer query comes in. It could be a simple billing issue, a complex technical problem, or even a feature request. Instead of routing the query directly to a specific department, you create a chain of handlers: billing support, technical support, and product management. The query starts at the beginning of the chain. If a handler can resolve the issue, it does. Otherwise, it passes the query to the next handler in the\u00a0chain.</p>\n<h3>Benefits of the Chain of Responsibility</h3>\n<ul>\n<li>\n<strong>Decoupling:</strong> The sender of a request is decoupled from its receiver.</li>\n<li>\n<strong>Flexible assignment:</strong> You can easily add or remove handlers from the\u00a0chain.</li>\n<li>\n<strong>Improved performance:</strong> By organizing handlers in a specific order, you can optimize processing.</li>\n</ul>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Handler</strong></li>\n<li><strong>Concrete Handler</strong></li>\n<li><strong>Client</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Y4Mu5aHz9wfboJ8sVjGWeA.png\"><figcaption>Class Diagram (Educative.io)</figcaption></figure><h3>Implementing the Chain of Responsibility</h3>\n<p>Let\u2019s create a simple example of a request for different types of\u00a0leaves.</p>\n<pre>interface Approver {<br>    void processRequest(LeaveRequest request);<br>    void setSuccessor(Approver successor);<br>}<br><br>class LeaveRequest {<br>    int days;<br><br>    public LeaveRequest(int days) {<br>        this.days = days;<br>    }<br>}<br><br>class Director extends Approver {<br>    private Approver successor;<br><br>    public void setSuccessor(Approver successor) {<br>        this.successor = successor;<br>    }<br><br>    public void processRequest(LeaveRequest request) {<br>        if (request.days &lt;= 10) {<br>            System.out.println(\"Director approved \" + request.days + \" days of leave.\");<br>        } else if (successor != null) {<br>            successor.processRequest(request);<br>        } else {<br>            System.out.println(\"No approver found for \" + request.days + \" days of leave.\");<br>        }<br>    }<br>}<br><br>class Manager extends Approver {<br>    private Approver successor;<br><br>    public void setSuccessor(Approver successor) {<br>        this.successor = successor;<br>    }<br><br>    public void processRequest(LeaveRequest request) {<br>        if (request.days &lt;= 5) {<br>            System.out.println(\"Manager approved \" + request.days + \" days of leave.\");<br>        } else if (successor != null) {<br>            successor.processRequest(request);<br>        } else {<br>            System.out.println(\"No approver found for \" + request.days + \" days of leave.\");<br>        }<br>    }<br>}<br><br>public class ChainOfResponsibilityDemo {<br>    public static void main(String[] args) {<br>        Director director = new Director();<br>        Manager manager = new Manager();<br><br>        director.setSuccessor(manager);<br><br>        LeaveRequest request1 = new LeaveRequest(3);<br>        LeaveRequest request2 = new LeaveRequest(7);<br>        LeaveRequest request3 = new LeaveRequest(15);<br><br>        director.processRequest(request1);<br>        director.processRequest(request2);<br>        director.processRequest(request3);<br>    }<br>}</pre>\n<h3>When to Use the Chain of Responsibility</h3>\n<ul>\n<li>When you have multiple objects that could handle a request, and you don\u2019t know beforehand which object will handle\u00a0it.</li>\n<li>When you want to avoid coupling the sender of a request to its receiver.</li>\n<li>When you want to support dynamic alterations of the chain of responsibility.</li>\n</ul>\n<h3>Other Examples</h3>\n<h4>1. Event Handling in JavaScript</h4>\n<ul>\n<li>\n<strong>Event propagation:</strong> When an event occurs on an HTML element, it travels through a chain of event handlers, starting from the innermost element and progressing outwards. Each element has the opportunity to handle the event or let it bubble up to the\u00a0parent.</li>\n<li>\n<strong>Event capturing:</strong> This is the opposite of bubbling, where the event starts from the outermost element and travels\u00a0inwards.</li>\n</ul>\n<h4>2. Servlet\u00a0Filters</h4>\n<ul>\n<li>\n<strong>Request processing:</strong> In Java Servlet technology, filters form a chain that processes incoming requests. Each filter can modify the request or response before passing it to the next filter in the chain. This allows for modular and flexible request handling.</li>\n<li>\n<strong>Filter chain:</strong> The FilterChain interface is used to pass the request and response to the next filter in the\u00a0chain.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>The Chain of Responsibility pattern is a powerful tool for managing request handling in complex systems. By understanding how to create and manage a chain of handlers, you can build flexible and efficient applications.</p>\n<p>Stay tuned for tomorrow\u2019s post, we\u2019ll dive into another behavioral pattern\u00a0: <strong>Observer\u00a0Pattern</strong>.</p>\n<p>Join me on this <a href=\"https://medium.com/@sourabhkr/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-day adventure</strong></a> as we conquer the world of design patterns together! Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a\u00a0clap\ud83d\udc4f!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bd8b9264ec44\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Introduction</h3>\n<p>Welcome to day 14 of our <a href=\"https://sourabhkr.medium.com/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-Day Design Pattern Challenge</strong></a>! Today we dive into our first behavioral pattern: the <strong>Chain of Responsibility</strong>. <em>This pattern is all about creating a chain of objects to handle a request, passing it along until an object in the chain can process\u00a0it.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*mZzdmxAKcQSo4ALIPaY30A.png\"><figcaption><strong>Illustration by Frits Ahlefeldt</strong></figcaption></figure><h3>Understanding the Chain of Responsibility</h3>\n<p>Imagine a customer support system. A customer query comes in. It could be a simple billing issue, a complex technical problem, or even a feature request. Instead of routing the query directly to a specific department, you create a chain of handlers: billing support, technical support, and product management. The query starts at the beginning of the chain. If a handler can resolve the issue, it does. Otherwise, it passes the query to the next handler in the\u00a0chain.</p>\n<h3>Benefits of the Chain of Responsibility</h3>\n<ul>\n<li>\n<strong>Decoupling:</strong> The sender of a request is decoupled from its receiver.</li>\n<li>\n<strong>Flexible assignment:</strong> You can easily add or remove handlers from the\u00a0chain.</li>\n<li>\n<strong>Improved performance:</strong> By organizing handlers in a specific order, you can optimize processing.</li>\n</ul>\n<h3>Class Diagram</h3>\n<p>The class diagram consists of the following entities</p>\n<ul>\n<li><strong>Handler</strong></li>\n<li><strong>Concrete Handler</strong></li>\n<li><strong>Client</strong></li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Y4Mu5aHz9wfboJ8sVjGWeA.png\"><figcaption>Class Diagram (Educative.io)</figcaption></figure><h3>Implementing the Chain of Responsibility</h3>\n<p>Let\u2019s create a simple example of a request for different types of\u00a0leaves.</p>\n<pre>interface Approver {<br>    void processRequest(LeaveRequest request);<br>    void setSuccessor(Approver successor);<br>}<br><br>class LeaveRequest {<br>    int days;<br><br>    public LeaveRequest(int days) {<br>        this.days = days;<br>    }<br>}<br><br>class Director extends Approver {<br>    private Approver successor;<br><br>    public void setSuccessor(Approver successor) {<br>        this.successor = successor;<br>    }<br><br>    public void processRequest(LeaveRequest request) {<br>        if (request.days &lt;= 10) {<br>            System.out.println(\"Director approved \" + request.days + \" days of leave.\");<br>        } else if (successor != null) {<br>            successor.processRequest(request);<br>        } else {<br>            System.out.println(\"No approver found for \" + request.days + \" days of leave.\");<br>        }<br>    }<br>}<br><br>class Manager extends Approver {<br>    private Approver successor;<br><br>    public void setSuccessor(Approver successor) {<br>        this.successor = successor;<br>    }<br><br>    public void processRequest(LeaveRequest request) {<br>        if (request.days &lt;= 5) {<br>            System.out.println(\"Manager approved \" + request.days + \" days of leave.\");<br>        } else if (successor != null) {<br>            successor.processRequest(request);<br>        } else {<br>            System.out.println(\"No approver found for \" + request.days + \" days of leave.\");<br>        }<br>    }<br>}<br><br>public class ChainOfResponsibilityDemo {<br>    public static void main(String[] args) {<br>        Director director = new Director();<br>        Manager manager = new Manager();<br><br>        director.setSuccessor(manager);<br><br>        LeaveRequest request1 = new LeaveRequest(3);<br>        LeaveRequest request2 = new LeaveRequest(7);<br>        LeaveRequest request3 = new LeaveRequest(15);<br><br>        director.processRequest(request1);<br>        director.processRequest(request2);<br>        director.processRequest(request3);<br>    }<br>}</pre>\n<h3>When to Use the Chain of Responsibility</h3>\n<ul>\n<li>When you have multiple objects that could handle a request, and you don\u2019t know beforehand which object will handle\u00a0it.</li>\n<li>When you want to avoid coupling the sender of a request to its receiver.</li>\n<li>When you want to support dynamic alterations of the chain of responsibility.</li>\n</ul>\n<h3>Other Examples</h3>\n<h4>1. Event Handling in JavaScript</h4>\n<ul>\n<li>\n<strong>Event propagation:</strong> When an event occurs on an HTML element, it travels through a chain of event handlers, starting from the innermost element and progressing outwards. Each element has the opportunity to handle the event or let it bubble up to the\u00a0parent.</li>\n<li>\n<strong>Event capturing:</strong> This is the opposite of bubbling, where the event starts from the outermost element and travels\u00a0inwards.</li>\n</ul>\n<h4>2. Servlet\u00a0Filters</h4>\n<ul>\n<li>\n<strong>Request processing:</strong> In Java Servlet technology, filters form a chain that processes incoming requests. Each filter can modify the request or response before passing it to the next filter in the chain. This allows for modular and flexible request handling.</li>\n<li>\n<strong>Filter chain:</strong> The FilterChain interface is used to pass the request and response to the next filter in the\u00a0chain.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>The Chain of Responsibility pattern is a powerful tool for managing request handling in complex systems. By understanding how to create and manage a chain of handlers, you can build flexible and efficient applications.</p>\n<p>Stay tuned for tomorrow\u2019s post, we\u2019ll dive into another behavioral pattern\u00a0: <strong>Observer\u00a0Pattern</strong>.</p>\n<p>Join me on this <a href=\"https://medium.com/@sourabhkr/starting-the-30-day-design-pattern-challenge-1971e570dc5b\"><strong>30-day adventure</strong></a> as we conquer the world of design patterns together! Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a\u00a0clap\ud83d\udc4f!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bd8b9264ec44\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["chain-of-responsibility","design-patterns","app-development","java-development","system-design-interview"]},{"title":"Day 13: Proxy Pattern","pubDate":"2024-07-29 20:41:22","link":"https://sourabhkr.medium.com/day-13-proxy-pattern-307c8732ecdc?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/307c8732ecdc","author":"Sourabh Kumar","thumbnail":"","description":"\n<h3>Introduction</h3>\n<p>Welcome back, design pattern enthusiasts! Today, we\u2019ll explore the <strong>Proxy Pattern</strong>, <em>a structural design pattern that provides a surrogate or placeholder for another object to control access to\u00a0it.</em></p>\n<h4>What is the Proxy\u00a0Pattern?</h4>\n<p>The Proxy Pattern introduces an intermediary object, known as a proxy, which acts as a stand-in for another object, called the real subject. This pattern offers several advantages, including:</p>\n<ul>\n<li>\n<strong>Controlled access:</strong> Proxies can regulate access to the real subject, implementing security checks or restrictions.</li>\n<li>\n<strong>Lazy loading:</strong> Proxies can defer the creation of the real subject until it\u2019s actually needed, optimizing performance.</li>\n<li>\n<strong>Remote access:</strong> Proxies can represent objects in different address spaces, providing a local representation for a remote\u00a0object.</li>\n<li>\n<strong>Virtual proxies:</strong> Proxies can provide additional functionality before or after a request is forwarded to the real\u00a0subject.</li>\n</ul>\n<h4>Problem</h4>\n<p>Consider a scenario where you\u2019re building an image viewer. Loading large images can be time-consuming. You want to display a low-resolution thumbnail quickly while the full-resolution image loads in the background.</p>\n<h4>Solution</h4>\n<p>The Proxy Pattern can address this by creating an image proxy. The proxy displays the thumbnail initially and then loads the full-size image when it\u2019s\u00a0ready.</p>\n<h4>How to Implement</h4>\n<ol>\n<li>\n<strong>Define the interface:</strong> Create an interface that both the real subject and proxy implement. This interface defines the operations that can be performed on the\u00a0object.</li>\n<li>\n<strong>Create the real subject:</strong> This is the actual object that the proxy represents.</li>\n<li>\n<strong>Create the proxy:</strong> The proxy holds a reference to the real subject and implements the same interface.</li>\n<li>\n<strong>Client code:</strong> The client interacts with the proxy, unaware of the underlying real\u00a0subject.</li>\n</ol>\n<h3>Class Diagram</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lH8tZ8eeaoRM0ZAQ4TOuVw.png\"><figcaption>Class Diagram</figcaption></figure><h4>Example</h4>\n<pre>interface Image {<br>    void display();<br>}<br><br>class RealImage implements Image {<br>    private String fileName;<br><br>    public RealImage(String fileName) {<br>        this.fileName = fileName;<br>        loadFromDisk(fileName);<br>    }<br><br>    private void loadFromDisk(String fileName) {<br>        // Simulate loading image from disk<br>        System.out.println(\"Loading \" + fileName);<br>    }<br><br>    public void display() {<br>        System.out.println(\"Displaying \" + fileName);<br>    }<br>}<br><br>class ProxyImage implements Image {<br>    private String fileName;<br>    private RealImage realImage;<br><br>    public ProxyImage(String fileName) {<br>        this.fileName = fileName;<br>    }<br><br>    public void display() {<br>        if (realImage == null) {<br>            realImage = new RealImage(fileName);<br>        }<br>        realImage.display();<br>    }<br>}</pre>\n<h4>Benefits</h4>\n<ul>\n<li>Improved performance: Lazy loading can significantly enhance performance.</li>\n<li>Controlled access: Proxies can enforce security or authorization checks.</li>\n<li>Simplified client code: Clients interact with the proxy, hiding the complexity of the real\u00a0object.</li>\n</ul>\n<h4>Disadvantages</h4>\n<ul>\n<li>Increased complexity: Introducing a proxy can add complexity to the\u00a0system.</li>\n<li>Performance overhead: In some cases, the proxy might introduce slight performance overhead.</li>\n</ul>\n<h4>When to\u00a0Use</h4>\n<ul>\n<li>To control access to an\u00a0object</li>\n<li>To lazy load\u00a0objects</li>\n<li>To represent remote\u00a0objects</li>\n<li>To provide additional functionality before or after a\u00a0request</li>\n</ul>\n<h4>Conclusion</h4>\n<p>The Proxy Pattern is a versatile design pattern that offers various benefits. By understanding its principles, you can effectively apply it to improve your object-oriented designs.</p>\n<p><strong>Stay tuned for Day 14, where we\u2019ll discuss our first Behavioral Pattern: <em>chain of responsibility pattern</em>!</strong></p>\n<p>Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0\ud83d\udc4f!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=307c8732ecdc\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Introduction</h3>\n<p>Welcome back, design pattern enthusiasts! Today, we\u2019ll explore the <strong>Proxy Pattern</strong>, <em>a structural design pattern that provides a surrogate or placeholder for another object to control access to\u00a0it.</em></p>\n<h4>What is the Proxy\u00a0Pattern?</h4>\n<p>The Proxy Pattern introduces an intermediary object, known as a proxy, which acts as a stand-in for another object, called the real subject. This pattern offers several advantages, including:</p>\n<ul>\n<li>\n<strong>Controlled access:</strong> Proxies can regulate access to the real subject, implementing security checks or restrictions.</li>\n<li>\n<strong>Lazy loading:</strong> Proxies can defer the creation of the real subject until it\u2019s actually needed, optimizing performance.</li>\n<li>\n<strong>Remote access:</strong> Proxies can represent objects in different address spaces, providing a local representation for a remote\u00a0object.</li>\n<li>\n<strong>Virtual proxies:</strong> Proxies can provide additional functionality before or after a request is forwarded to the real\u00a0subject.</li>\n</ul>\n<h4>Problem</h4>\n<p>Consider a scenario where you\u2019re building an image viewer. Loading large images can be time-consuming. You want to display a low-resolution thumbnail quickly while the full-resolution image loads in the background.</p>\n<h4>Solution</h4>\n<p>The Proxy Pattern can address this by creating an image proxy. The proxy displays the thumbnail initially and then loads the full-size image when it\u2019s\u00a0ready.</p>\n<h4>How to Implement</h4>\n<ol>\n<li>\n<strong>Define the interface:</strong> Create an interface that both the real subject and proxy implement. This interface defines the operations that can be performed on the\u00a0object.</li>\n<li>\n<strong>Create the real subject:</strong> This is the actual object that the proxy represents.</li>\n<li>\n<strong>Create the proxy:</strong> The proxy holds a reference to the real subject and implements the same interface.</li>\n<li>\n<strong>Client code:</strong> The client interacts with the proxy, unaware of the underlying real\u00a0subject.</li>\n</ol>\n<h3>Class Diagram</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*lH8tZ8eeaoRM0ZAQ4TOuVw.png\"><figcaption>Class Diagram</figcaption></figure><h4>Example</h4>\n<pre>interface Image {<br>    void display();<br>}<br><br>class RealImage implements Image {<br>    private String fileName;<br><br>    public RealImage(String fileName) {<br>        this.fileName = fileName;<br>        loadFromDisk(fileName);<br>    }<br><br>    private void loadFromDisk(String fileName) {<br>        // Simulate loading image from disk<br>        System.out.println(\"Loading \" + fileName);<br>    }<br><br>    public void display() {<br>        System.out.println(\"Displaying \" + fileName);<br>    }<br>}<br><br>class ProxyImage implements Image {<br>    private String fileName;<br>    private RealImage realImage;<br><br>    public ProxyImage(String fileName) {<br>        this.fileName = fileName;<br>    }<br><br>    public void display() {<br>        if (realImage == null) {<br>            realImage = new RealImage(fileName);<br>        }<br>        realImage.display();<br>    }<br>}</pre>\n<h4>Benefits</h4>\n<ul>\n<li>Improved performance: Lazy loading can significantly enhance performance.</li>\n<li>Controlled access: Proxies can enforce security or authorization checks.</li>\n<li>Simplified client code: Clients interact with the proxy, hiding the complexity of the real\u00a0object.</li>\n</ul>\n<h4>Disadvantages</h4>\n<ul>\n<li>Increased complexity: Introducing a proxy can add complexity to the\u00a0system.</li>\n<li>Performance overhead: In some cases, the proxy might introduce slight performance overhead.</li>\n</ul>\n<h4>When to\u00a0Use</h4>\n<ul>\n<li>To control access to an\u00a0object</li>\n<li>To lazy load\u00a0objects</li>\n<li>To represent remote\u00a0objects</li>\n<li>To provide additional functionality before or after a\u00a0request</li>\n</ul>\n<h4>Conclusion</h4>\n<p>The Proxy Pattern is a versatile design pattern that offers various benefits. By understanding its principles, you can effectively apply it to improve your object-oriented designs.</p>\n<p><strong>Stay tuned for Day 14, where we\u2019ll discuss our first Behavioral Pattern: <em>chain of responsibility pattern</em>!</strong></p>\n<p>Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0\ud83d\udc4f!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=307c8732ecdc\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["proxy-pattern","system-design-concepts","java","design-patterns","system-design-interview"]},{"title":"Day 12: Flyweight Pattern","pubDate":"2024-07-28 20:00:11","link":"https://sourabhkr.medium.com/day-12-flyweight-pattern-53400c13df6a?source=rss-4cc8effadc6e------2","guid":"https://medium.com/p/53400c13df6a","author":"Sourabh Kumar","thumbnail":"","description":"\n<p>Welcome back, design pattern enthusiasts! Today, we\u2019ll delve into the <strong>Flyweight Pattern</strong>, <em>another powerful tool in your object-oriented programming arsenal. This pattern focuses on reducing memory usage by sharing objects that contain the same\u00a0state.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*gcNb2dAXRIqjqh58QbxGfQ.png\"></figure><h4><strong>What is\u00a0it?</strong></h4>\n<p>The Flyweight Pattern promotes efficient memory usage by creating and sharing objects that represent identical or similar data. It involves a Factory that manages a pool of flyweight objects and ensures their\u00a0reuse.</p>\n<h4><strong>Problem</strong></h4>\n<p>Imagine you\u2019re building a game with hundreds of enemy characters. Each character might have attributes like position, size, and image. Creating a separate object for every enemy can quickly consume a lot of memory, especially for complex characters.</p>\n<h4><strong>Solution</strong></h4>\n<p>The Flyweight Pattern addresses this by separating an object\u2019s intrinsic state (data unique to each object) from its extrinsic state (data that can be shared). The flyweight objects hold the intrinsic state, while the client code manages the extrinsic state for each instance.</p>\n<h4><strong>How to Implement</strong></h4>\n<ol>\n<li>\n<strong>Define an Interface:</strong> Create an interface that defines the operations common to all flyweight objects.</li>\n<li>\n<strong>Implement Flyweight Objects:</strong> Implement concrete classes that represent the flyweight objects. These classes hold the intrinsic state and provide methods to access\u00a0it.</li>\n<li>\n<strong>Create a Flyweight Factory:</strong> Implement a Factory class responsible for creating and managing flyweight objects. The Factory maintains a pool of existing flyweight objects and ensures they are reused whenever possible.</li>\n<li>\n<strong>Client Code:</strong> The client code interacts with the flyweight objects through the interface. It manages the extrinsic state and retrieves the appropriate flyweight object from the\u00a0Factory.</li>\n</ol>\n<h4><strong>Class Diagram</strong></h4>\n<p>The class diagram involves these entities:</p>\n<ul>\n<li>\n<strong>Flyweight:</strong> The base interface defining the operations common to all flyweight objects.</li>\n<li>\n<strong>Concrete Flyweight:</strong> Implements the Flyweight interface and holds the intrinsic state.</li>\n<li>\n<strong>Flyweight Factory:</strong> Creates and manages flyweight objects, ensuring\u00a0reuse.</li>\n<li>\n<strong>Client:</strong> Interacts with flyweight objects through the interface and manages the extrinsic state.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wpoxcbYCYaFaO-HVNxrBQw.png\"><figcaption>Class Diagram</figcaption></figure><h4><strong>Example</strong></h4>\n<p>Let\u2019s consider a game with colored trees. The intrinsic state of a tree is its color (e.g., green, brown). The extrinsic state is its position on the\u00a0map.</p>\n<ul><li>\n<strong>Flyweight:</strong> This could be an interface Tree with methods like\u00a0draw().</li></ul>\n<pre>interface Tree {<br>    void draw(int x, int y, int depth);<br>}</pre>\n<ul><li>\n<strong>Concrete Flyweight:</strong> We could have classes like GreenTree and BrownTree implementing Tree and holding the color\u00a0data.</li></ul>\n<pre>class GreenTree implements Tree {<br>    public void draw(int x, int y, int depth) {<br>        // Draw green tree at (x, y) with depth<br>        System.out.println(\"Drawing green tree at (\" + x + \", \" + y + \"), depth: \" + depth);<br>    }<br>}<br><br>class BrownTree implements Tree {<br>    public void draw(int x, int y, int depth) {<br>        // Draw brown tree at (x, y) with depth<br>        System.out.println(\"Drawing brown tree at (\" + x + \", \" + y + \"), depth: \" + depth);<br>    }<br>}</pre>\n<ul><li>\n<strong>Flyweight Factory:</strong> This class would maintain a pool of GreenTree and BrownTree objects. When the client requests a tree, the Factory checks its pool and returns an existing object or creates a new one if none are available.</li></ul>\n<pre>class TreeFactory {<br>    private Map&lt;String, Tree&gt; treeMap = new HashMap&lt;&gt;();<br><br>    public Tree getTree(String name) {<br>        Tree tree = treeMap.get(name);<br>        if (tree == null) {<br>            switch (name) {<br>                case \"Green\":<br>                    tree = new GreenTree();<br>                    break;<br>                case \"Brown\":<br>                    tree = new BrownTree();<br>                    break;<br>                default:<br>                    throw new IllegalArgumentException(\"Tree not found: \" + name);<br>            }<br>            treeMap.put(name, tree);<br>        }<br>        return tree;<br>    }<br>}</pre>\n<ul><li>\n<strong>Client:</strong> The client code would interact with Tree objects, specifying their position on the map while using the Factory to retrieve the appropriate colored\u00a0tree.</li></ul>\n<pre>public class FlyweightPatternDemo {<br>    public static void main(String[] args) {<br>        TreeFactory treeFactory = new TreeFactory();<br>        Tree tree1 = treeFactory.getTree(\"Green\");<br>        Tree tree2 = treeFactory.getTree(\"Brown\");<br>        Tree tree3 = treeFactory.getTree(\"Green\"); // Reused<br><br>        tree1.draw(10, 20, 30);<br>        tree2.draw(40, 50, 60);<br>        tree3.draw(70, 80, 90);<br>    }<br>}</pre>\n<h4><strong>Benefits</strong></h4>\n<ul>\n<li>\n<strong>Reduced Memory Usage:</strong> By sharing objects, the Flyweight Pattern significantly reduces memory consumption, especially for large numbers of similar\u00a0objects.</li>\n<li>\n<strong>Improved Performance:</strong> Creating and managing fewer objects can lead to performance improvements.</li>\n<li>\n<strong>Flexibility:</strong> The pattern allows for efficient creation of complex objects with shared and unique\u00a0data.</li>\n</ul>\n<h4><strong>Disadvantages</strong></h4>\n<ul>\n<li>\n<strong>Increased Complexity:</strong> Implementing the Flyweight Pattern might introduce additional complexity compared to a simpler approach.</li>\n<li>\n<strong>Not Suitable for All Objects:</strong> It\u2019s not ideal for objects with a high degree of unique\u00a0data.</li>\n</ul>\n<h4><strong>When to\u00a0Use</strong></h4>\n<ul>\n<li>When dealing with a large number of similar objects with shared\u00a0data.</li>\n<li>When memory usage is a critical\u00a0concern.</li>\n<li>When creating complex objects with a mix of shared and unique\u00a0data.</li>\n</ul>\n<h4><strong>When Not to\u00a0Use</strong></h4>\n<ul>\n<li>For a small number of unique\u00a0objects.</li>\n<li>When memory usage is not a significant concern.</li>\n<li>When object creation is a simple and non-expensive operation.</li>\n</ul>\n<h4><strong>Conclusion</strong></h4>\n<p>The Flyweight Pattern is a valuable technique for optimizing memory usage and improving performance in scenarios with numerous similar objects. By understanding its benefits and drawbacks, you can effectively apply this pattern to create efficient and scalable object-oriented applications.</p>\n<p><strong>Stay tuned for Day 13, where we\u2019ll explore the Proxy Pattern! Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=53400c13df6a\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Welcome back, design pattern enthusiasts! Today, we\u2019ll delve into the <strong>Flyweight Pattern</strong>, <em>another powerful tool in your object-oriented programming arsenal. This pattern focuses on reducing memory usage by sharing objects that contain the same\u00a0state.</em></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*gcNb2dAXRIqjqh58QbxGfQ.png\"></figure><h4><strong>What is\u00a0it?</strong></h4>\n<p>The Flyweight Pattern promotes efficient memory usage by creating and sharing objects that represent identical or similar data. It involves a Factory that manages a pool of flyweight objects and ensures their\u00a0reuse.</p>\n<h4><strong>Problem</strong></h4>\n<p>Imagine you\u2019re building a game with hundreds of enemy characters. Each character might have attributes like position, size, and image. Creating a separate object for every enemy can quickly consume a lot of memory, especially for complex characters.</p>\n<h4><strong>Solution</strong></h4>\n<p>The Flyweight Pattern addresses this by separating an object\u2019s intrinsic state (data unique to each object) from its extrinsic state (data that can be shared). The flyweight objects hold the intrinsic state, while the client code manages the extrinsic state for each instance.</p>\n<h4><strong>How to Implement</strong></h4>\n<ol>\n<li>\n<strong>Define an Interface:</strong> Create an interface that defines the operations common to all flyweight objects.</li>\n<li>\n<strong>Implement Flyweight Objects:</strong> Implement concrete classes that represent the flyweight objects. These classes hold the intrinsic state and provide methods to access\u00a0it.</li>\n<li>\n<strong>Create a Flyweight Factory:</strong> Implement a Factory class responsible for creating and managing flyweight objects. The Factory maintains a pool of existing flyweight objects and ensures they are reused whenever possible.</li>\n<li>\n<strong>Client Code:</strong> The client code interacts with the flyweight objects through the interface. It manages the extrinsic state and retrieves the appropriate flyweight object from the\u00a0Factory.</li>\n</ol>\n<h4><strong>Class Diagram</strong></h4>\n<p>The class diagram involves these entities:</p>\n<ul>\n<li>\n<strong>Flyweight:</strong> The base interface defining the operations common to all flyweight objects.</li>\n<li>\n<strong>Concrete Flyweight:</strong> Implements the Flyweight interface and holds the intrinsic state.</li>\n<li>\n<strong>Flyweight Factory:</strong> Creates and manages flyweight objects, ensuring\u00a0reuse.</li>\n<li>\n<strong>Client:</strong> Interacts with flyweight objects through the interface and manages the extrinsic state.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wpoxcbYCYaFaO-HVNxrBQw.png\"><figcaption>Class Diagram</figcaption></figure><h4><strong>Example</strong></h4>\n<p>Let\u2019s consider a game with colored trees. The intrinsic state of a tree is its color (e.g., green, brown). The extrinsic state is its position on the\u00a0map.</p>\n<ul><li>\n<strong>Flyweight:</strong> This could be an interface Tree with methods like\u00a0draw().</li></ul>\n<pre>interface Tree {<br>    void draw(int x, int y, int depth);<br>}</pre>\n<ul><li>\n<strong>Concrete Flyweight:</strong> We could have classes like GreenTree and BrownTree implementing Tree and holding the color\u00a0data.</li></ul>\n<pre>class GreenTree implements Tree {<br>    public void draw(int x, int y, int depth) {<br>        // Draw green tree at (x, y) with depth<br>        System.out.println(\"Drawing green tree at (\" + x + \", \" + y + \"), depth: \" + depth);<br>    }<br>}<br><br>class BrownTree implements Tree {<br>    public void draw(int x, int y, int depth) {<br>        // Draw brown tree at (x, y) with depth<br>        System.out.println(\"Drawing brown tree at (\" + x + \", \" + y + \"), depth: \" + depth);<br>    }<br>}</pre>\n<ul><li>\n<strong>Flyweight Factory:</strong> This class would maintain a pool of GreenTree and BrownTree objects. When the client requests a tree, the Factory checks its pool and returns an existing object or creates a new one if none are available.</li></ul>\n<pre>class TreeFactory {<br>    private Map&lt;String, Tree&gt; treeMap = new HashMap&lt;&gt;();<br><br>    public Tree getTree(String name) {<br>        Tree tree = treeMap.get(name);<br>        if (tree == null) {<br>            switch (name) {<br>                case \"Green\":<br>                    tree = new GreenTree();<br>                    break;<br>                case \"Brown\":<br>                    tree = new BrownTree();<br>                    break;<br>                default:<br>                    throw new IllegalArgumentException(\"Tree not found: \" + name);<br>            }<br>            treeMap.put(name, tree);<br>        }<br>        return tree;<br>    }<br>}</pre>\n<ul><li>\n<strong>Client:</strong> The client code would interact with Tree objects, specifying their position on the map while using the Factory to retrieve the appropriate colored\u00a0tree.</li></ul>\n<pre>public class FlyweightPatternDemo {<br>    public static void main(String[] args) {<br>        TreeFactory treeFactory = new TreeFactory();<br>        Tree tree1 = treeFactory.getTree(\"Green\");<br>        Tree tree2 = treeFactory.getTree(\"Brown\");<br>        Tree tree3 = treeFactory.getTree(\"Green\"); // Reused<br><br>        tree1.draw(10, 20, 30);<br>        tree2.draw(40, 50, 60);<br>        tree3.draw(70, 80, 90);<br>    }<br>}</pre>\n<h4><strong>Benefits</strong></h4>\n<ul>\n<li>\n<strong>Reduced Memory Usage:</strong> By sharing objects, the Flyweight Pattern significantly reduces memory consumption, especially for large numbers of similar\u00a0objects.</li>\n<li>\n<strong>Improved Performance:</strong> Creating and managing fewer objects can lead to performance improvements.</li>\n<li>\n<strong>Flexibility:</strong> The pattern allows for efficient creation of complex objects with shared and unique\u00a0data.</li>\n</ul>\n<h4><strong>Disadvantages</strong></h4>\n<ul>\n<li>\n<strong>Increased Complexity:</strong> Implementing the Flyweight Pattern might introduce additional complexity compared to a simpler approach.</li>\n<li>\n<strong>Not Suitable for All Objects:</strong> It\u2019s not ideal for objects with a high degree of unique\u00a0data.</li>\n</ul>\n<h4><strong>When to\u00a0Use</strong></h4>\n<ul>\n<li>When dealing with a large number of similar objects with shared\u00a0data.</li>\n<li>When memory usage is a critical\u00a0concern.</li>\n<li>When creating complex objects with a mix of shared and unique\u00a0data.</li>\n</ul>\n<h4><strong>When Not to\u00a0Use</strong></h4>\n<ul>\n<li>For a small number of unique\u00a0objects.</li>\n<li>When memory usage is not a significant concern.</li>\n<li>When object creation is a simple and non-expensive operation.</li>\n</ul>\n<h4><strong>Conclusion</strong></h4>\n<p>The Flyweight Pattern is a valuable technique for optimizing memory usage and improving performance in scenarios with numerous similar objects. By understanding its benefits and drawbacks, you can effectively apply this pattern to create efficient and scalable object-oriented applications.</p>\n<p><strong>Stay tuned for Day 13, where we\u2019ll explore the Proxy Pattern! Feel free to leave comments or questions below. If you enjoyed this blog, consider giving it a clap\u00a0!</strong></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=53400c13df6a\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["flyweight-pattern","design-pattern-challenge","design-pattern-in-java","system-design-concepts","system-design-interview"]}]}